Logic optimization is a process of finding an equivalent representation of the specified logic circuit under one or more specified constraints. This process is a part of a logic synthesis applied in digital electronics and integrated circuit design .

Generally, the circuit is constrained to a minimum chip area meeting a predefined response delay. The goal of logic optimization of a given circuit is to obtain the smallest logic circuit that evaluates to the same values as the original one. Usually, the smaller circuit with the same function is cheaper, takes less space, consumes less power , has shorter latency, and minimizes risks of unexpected cross-talk , hazard of delayed signal processing , and other issues present at the nano-scale level of metallic structures on an integrated circuit .

In terms of Boolean algebra , the optimization of a complex Boolean expression is a process of finding a simpler one, which would upon evaluation ultimately produce the same results as the original one.

The problem with having a complicated circuit (i.e. one with many elements, such as logic gates ) is that each element takes up physical space and costs time and money to produce. Circuit minimization may be one form of logic optimization used to reduce the area of complex logic in integrated circuits .

With the advent of logic synthesis , one of the biggest challenges faced by the electronic design automation (EDA) industry was to find the most simple circuit representation of the given design description. While two-level logic optimization had long existed in the form of the Quine–McCluskey algorithm , later followed by the Espresso heuristic logic minimizer , the rapidly improving chip densities, and the wide adoption of Hardware description languages for circuit description, formalized the logic optimization domain as it exists today, including Logic Friday (graphical interface), Minilog, and ESPRESSO-IISOJS (many-valued logic).

The methods of logic circuit simplifications are equally applicable to Boolean expression minimization .

Today, logic optimization is divided into various categories:

Graphical methods represent the required logical function by a diagram representing the logic variables and value of the function. By manipulating or inspecting a diagram, much tedious calculation may be eliminated. 
Graphical minimization methods for two-level logic include:

The same methods of Boolean expression minimization (simplification) listed below may be applied to the circuit optimization.

For the case when the Boolean function is specified by a circuit (that is, we want to find an equivalent circuit of minimum size possible), the unbounded circuit minimization problem was long-conjectured to be Σ 2 P {\displaystyle \Sigma _{2}^{P}} -complete in time complexity , a result finally proved in 2008, but there are effective heuristics such as Karnaugh maps and the Quine–McCluskey algorithm that facilitate the process.

Boolean function minimizing methods include:

Methods that find optimal circuit representations of Boolean functions are often referred to as exact synthesis in the literature. Due to the computational complexity, exact synthesis is tractable only for small Boolean functions. Recent approaches map the optimization problem to a Boolean satisfiability problem. This allows finding optimal circuit representations using a SAT solver .

A heuristic method uses established rules that solve a practical useful subset of the much larger possible set of problems. The heuristic method may not produce the theoretically optimum solution, but if useful, will provide most of the optimization desired with a minimum of effort. An example of a computer system that uses heuristic methods for logic optimization is the Espresso heuristic logic minimizer .

While a two-level circuit representation of circuits strictly refers to the flattened view of the circuit in terms of SOPs ( sum-of-products ) — which is more applicable to a PLA implementation of the design — a multi-level representation is a more generic view of the circuit in terms of arbitrarily connected SOPs, POSs ( product-of-sums ), factored form etc. Logic optimization algorithms generally work either on the structural (SOPs, factored form) or functional representation ( binary decision diagrams , algebraic decision diagrams ) of the circuit. In sum-of-products (SOP) form, AND gates form the smallest unit and are stitched together using ORs, whereas in product-of-sums (POS) form it is opposite.  POS form requires parentheses to group the OR terms together under AND gates, because OR has lower precedence than AND.  Both SOP and POS forms translate nicely into circuit logic.

If we have two functions F 1 and F 2 :

The above 2-level representation takes six product terms and 24 transistors in CMOS Rep.

A functionally equivalent representation in multilevel can be:

While the number of levels here is 3, the total number of product terms and literals reduce because of the sharing of the term B + C.

Similarly, we distinguish between combinational circuits and sequential circuits . Combinational circuits produce their outputs based only on the current inputs. They can be represented by Boolean relations . Some examples are priority encoders , binary decoders , multiplexers , demultiplexers .

Sequential circuits produce their output based on both current and past inputs, depending on a clock signal to distinguish the previous inputs from the current inputs. They can be represented by finite state machines. Some examples are flip-flops and counters .

While there are many ways to minimize a circuit, this is an example that minimizes (or simplifies) a Boolean function. The Boolean function carried out by the circuit is directly related to the algebraic expression from which the function is implemented. Consider the circuit used to represent ( A ∧ B ¯ ) ∨ ( A ¯ ∧ B ) {\displaystyle (A\wedge {\bar {B}})\vee ({\bar {A}}\wedge B)} . It is evident that two negations, two conjunctions, and a disjunction are used in this statement. This means that to build the circuit one would need two inverters , two AND gates , and an OR gate .

The circuit can simplified (minimized) by applying laws of Boolean algebra or using intuition. Since the example states that A {\displaystyle A} is true when B {\displaystyle B} is false and the other way around, one can conclude that this simply means A ≠ B {\displaystyle A\neq B} . In terms of logical gates, inequality simply means an XOR gate (exclusive or). Therefore, ( A ∧ B ¯ ) ∨ ( A ¯ ∧ B ) ⟺ A ≠ B {\displaystyle (A\wedge {\bar {B}})\vee ({\bar {A}}\wedge B)\iff A\neq B} . Then the two circuits shown below are equivalent, as can be checked using a truth table :