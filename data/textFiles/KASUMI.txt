KASUMI is a block cipher used in UMTS , GSM , and GPRS mobile communications systems.
In UMTS, KASUMI is used in the confidentiality ( f8 ) and integrity algorithms ( f9 ) with names UEA1 and UIA1, respectively. In GSM, KASUMI is used in the A5/3 key stream generator and in GPRS in the GEA3 key stream generator.

KASUMI was designed for 3GPP to be used in UMTS security system by the Security Algorithms Group of Experts (SAGE), a part of the European standards body ETSI . Because of schedule pressures in 3GPP standardization, instead of developing a new cipher, SAGE agreed with 
3GPP technical specification group (TSG) for system aspects of 3G security (SA3) to base the development
on an existing algorithm that had already undergone some evaluation. They chose the cipher algorithm MISTY1 developed and patented by Mitsubishi Electric Corporation .
The original algorithm was slightly modified for easier hardware implementation and to
meet other requirements set for 3G mobile communications security.

KASUMI is named after the original algorithm MISTY1 — 霞み (hiragana かすみ , romaji kasumi ) is the Japanese word for "mist".

In January 2010, Orr Dunkelman , Nathan Keller and Adi Shamir released a paper showing that they could break Kasumi with a related-key attack and very modest computational resources; this attack is ineffective against MISTY1 .

KASUMI algorithm is specified in a 3GPP technical specification. KASUMI is a block cipher with 128-bit key and 64-bit input and output. 
The core of KASUMI is an eight-round Feistel network . The round functions
in the main Feistel network are irreversible Feistel-like network
transformations. In each round the round function uses a round key
which consists of eight 16-bit sub keys
derived from the original 128-bit key using a fixed key schedule.

The 128-bit key K is divided into eight 16-bit sub keys K i :

K = K 1 ‖ K 2 ‖ K 3 ‖ K 4 ‖ K 5 ‖ K 6 ‖ K 7 ‖ K 8 {\displaystyle K=K_{1}\|K_{2}\|K_{3}\|K_{4}\|K_{5}\|K_{6}\|K_{7}\|K_{8}\,}

Additionally a modified key K' , similarly divided into 16-bit
sub keys K' i , is used. The modified key is derived from
the original key by XORing with 0x123456789ABCDEFFEDCBA9876543210 (chosen as a "nothing up my sleeve" number ).

Round keys are either derived from the sub keys by bitwise rotation to left
by a given amount and from the modified sub keys (unchanged).

The round keys are as follows:

K L i , 1 = R O L ( K i , 1 ) K L i , 2 = K i + 2 ′ K O i , 1 = R O L ( K i + 1 , 5 ) K O i , 2 = R O L ( K i + 5 , 8 ) K O i , 3 = R O L ( K i + 6 , 13 ) K I i , 1 = K i + 4 ′ K I i , 2 = K i + 3 ′ K I i , 3 = K i + 7 ′ {\displaystyle {\begin{array}{lcl}KL_{i,1}&=&{\rm {ROL}}(K_{i},1)\\KL_{i,2}&=&K'_{i+2}\\KO_{i,1}&=&{\rm {ROL}}(K_{i+1},5)\\KO_{i,2}&=&{\rm {ROL}}(K_{i+5},8)\\KO_{i,3}&=&{\rm {ROL}}(K_{i+6},13)\\KI_{i,1}&=&K'_{i+4}\\KI_{i,2}&=&K'_{i+3}\\KI_{i,3}&=&K'_{i+7}\end{array}}}

Sub key index additions are cyclic so that if i+j is greater than 8
one has to subtract 8 from the result to get the actual sub key index.

KASUMI algorithm processes the 64-bit word in two 32-bit halves, left ( L i {\displaystyle L_{i}} )
and right ( R i {\displaystyle R_{i}} ).
The input word is concatenation of the left and right halves of the first round:

i n p u t = R 0 ‖ L 0 {\displaystyle {\rm {input}}=R_{0}\|L_{0}\,} .

In each round the right half is XOR'ed with the output of the round function
after which the halves are swapped:

L i = F i ( K L i , K O i , K I i , L i − 1 ) ⊕ R i − 1 R i = L i − 1 {\displaystyle {\begin{array}{rcl}L_{i}&=&F_{i}(KL_{i},KO_{i},KI_{i},L_{i-1})\oplus R_{i-1}\\R_{i}&=&L_{i-1}\end{array}}}

where KL i , KO i , KI i are round keys
for the i round.

The round functions for even and odd rounds are slightly different. In each case
the round function is a composition of two functions FL i and FO i .
For an odd round

F i ( K i , L i − 1 ) = F O ( K O i , K I i , F L ( K L i , L i − 1 ) ) {\displaystyle F_{i}(K_{i},L_{i-1})=FO(KO_{i},KI_{i},FL(KL_{i},L_{i-1}))\,}

and for an even round

F i ( K i , L i − 1 ) = F L ( K L i , F O ( K O i , K I i , L i − 1 ) ) {\displaystyle F_{i}(K_{i},L_{i-1})=FL(KL_{i},FO(KO_{i},KI_{i},L_{i-1}))\,} .

The output is the concatenation of the outputs of the last round.

o u t p u t = R 8 ‖ L 8 {\displaystyle {\rm {output}}=R_{8}\|L_{8}\,} .

Both FL and FO functions divide the 32-bit input data to two 16-bit halves.
The FL function is an irreversible bit manipulation while the FO function is
an irreversible three round Feistel-like network.

The 32-bit input x of F L ( K L i , x ) {\displaystyle FL(KL_{i},x)} is divided to two 16-bit  halves x = l ‖ r {\displaystyle x=l\|r} .
First the left half of the input l {\displaystyle l} is ANDed bitwise with round key K L i , 1 {\displaystyle KL_{i,1}} and rotated
left by one bit. The result of that is XOR'ed to the right half of the input r {\displaystyle r} to get the right
half of  the output r ′ {\displaystyle r'} .

r ′ = R O L ( l ∧ K L i , 1 , 1 ) ⊕ r {\displaystyle r'={\rm {ROL}}(l\wedge KL_{i,1},1)\oplus r}

Then the right half of the output r ′ {\displaystyle r'} is ORed bitwise with the round key K L i , 2 {\displaystyle KL_{i,2}} and rotated
left by one bit. The result of that is XOR'ed to the left half of the input l {\displaystyle l} to get the left
half of the output l ′ {\displaystyle l'} .

l ′ = R O L ( r ′ ∨ K L i , 2 , 1 ) ⊕ l {\displaystyle l'={\rm {ROL}}(r'\vee KL_{i,2},1)\oplus l}

Output of the function is concatenation of the left and right halves x ′ = l ′ ‖ r ′ {\displaystyle x'=l'\|r'} .

The 32-bit input x of F O ( K O i , K I i , x ) {\displaystyle FO(KO_{i},KI_{i},x)} is divided into two 16-bit halves x = l 0 ‖ r 0 {\displaystyle x=l_{0}\|r_{0}} , and passed through three rounds of a Feistel network.

In each of the three rounds (indexed by j that takes values 1, 2, and 3) the left half is modified
to get the new right half and the right half is made the left half of the next round.

r j = F I ( K I i , j , l j − 1 ⊕ K O i , j ) ⊕ r j − 1 l j = r j − 1 {\displaystyle {\begin{array}{lcl}r_{j}&=&FI(KI_{i,j},l_{j-1}\oplus KO_{i,j})\oplus r_{j-1}\\l_{j}&=&r_{j-1}\end{array}}}

The output of the function is x ′ = l 3 ‖ r 3 {\displaystyle x'=l_{3}\|r_{3}} .

The function FI is an irregular Feistel-like network.

The 16-bit input x {\displaystyle x} of the function F I ( K i , x ) {\displaystyle FI(Ki,x)} is divided to two halves x = l 0 ‖ r 0 {\displaystyle x=l_{0}\|r_{0}} of which l 0 {\displaystyle l_{0}} is 9 bits wide and r 0 {\displaystyle r_{0}} is 7 bits wide.

Bits in the left half l 0 {\displaystyle l_{0}} are first shuffled by 9-bit substitution box (S-box) S9 and the result is XOR'ed with
the zero-extended right half r 0 {\displaystyle r_{0}} to get the new 9-bit right half r 1 {\displaystyle r_{1}} .

r 1 = S 9 ( l 0 ) ⊕ ( 00 ‖ r 0 ) {\displaystyle r_{1}=S9(l_{0})\oplus (00\|r_{0})\,}

Bits of the right half r 0 {\displaystyle r_{0}} are shuffled by 7-bit S-box S7 and the result is XOR'ed with
the seven least significant bits ( LS7 ) of the new right half r 1 {\displaystyle r_{1}} to get the new 7-bit left half l 1 {\displaystyle l_{1}} .

l 1 = S 7 ( r 0 ) ⊕ L S 7 ( r 1 ) {\displaystyle l_{1}=S7(r_{0})\oplus LS7(r_{1})\,}

The intermediate word x 1 = l 1 ‖ r 1 {\displaystyle x_{1}=l_{1}\|r_{1}} is XORed with the round key KI to get x 2 = l 2 ‖ r 2 {\displaystyle x_{2}=l_{2}\|r_{2}} of which l 2 {\displaystyle l_{2}} is 7 bits wide and r 2 {\displaystyle r_{2}} is 9 bits wide.

x 2 = K I ⊕ x 1 {\displaystyle x_{2}=KI\oplus x_{1}}

Bits in the right half r 2 {\displaystyle r_{2}} are then shuffled by 9-bit S-box S9 and the result is XOR'ed with
the zero-extended left half l 2 {\displaystyle l_{2}} to get the new 9-bit right half of the output r 3 {\displaystyle r_{3}} .

r 3 = S 9 ( r 2 ) ⊕ ( 00 ‖ l 2 ) {\displaystyle r_{3}=S9(r_{2})\oplus (00\|l_{2})\,}

Finally the bits of the left half l 2 {\displaystyle l_{2}} are shuffled by 7-bit S-box S7 and the result is XOR'ed with
the seven least significant bits ( LS7 ) of the right half of the output r 3 {\displaystyle r_{3}} to get the 7-bit left
half l 3 {\displaystyle l_{3}} of the output.

l 3 = S 7 ( l 2 ) ⊕ L S 7 ( r 3 ) {\displaystyle l_{3}=S7(l_{2})\oplus LS7(r_{3})\,}

The output is the concatenation of the final left and right halves x ′ = l 3 ‖ r 3 {\displaystyle x'=l_{3}\|r_{3}} .

The substitution boxes (S-boxes) S7 and S9 are defined by both bit-wise AND-XOR expressions and look-up tables in the specification.
The bit-wise expressions are intended to hardware implementation but nowadays it is customary to use
the look-up tables even in the HW design.

S7 is defined by the following array:

S9 is defined by the following array:

In 2001, an impossible differential attack on six rounds of KASUMI was presented by Kühn (2001).

In 2003 Elad Barkan, Eli Biham and Nathan Keller demonstrated man-in-the-middle attacks against the GSM protocol which avoided the A5/3 cipher and thus breaking the protocol. This approach does not attack the A5/3 cipher, however. The full version of their paper was published later in 2006.

In 2005, Israeli researchers Eli Biham , Orr Dunkelman and Nathan Keller published a related-key rectangle (boomerang) attack on KASUMI that can break all 8 rounds faster than exhaustive search. The attack requires 2 chosen plaintexts, each of which has been encrypted under one of four related keys, and has a time complexity equivalent to 2 KASUMI encryptions. While this is obviously not a practical attack, it invalidates some proofs about the security of the 3GPP protocols that had relied on the presumed strength of KASUMI.

In 2010, Dunkelman, Keller and Shamir published a new attack that allows an adversary to recover a full A5/3 key by related-key attack . The time and space complexities of the attack are low enough that the authors carried out the attack in two hours on an Intel Core 2 Duo desktop computer even using the unoptimized reference KASUMI implementation. The authors note that this attack may not be applicable to the way A5/3 is used in 3G systems; their main purpose was to discredit 3GPP's assurances that their changes to MISTY wouldn't significantly impact the security of the algorithm.