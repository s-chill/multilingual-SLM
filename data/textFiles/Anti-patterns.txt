An anti-pattern in software engineering , project management , and business processes is a common response to a recurring problem that is usually ineffective and risks being highly counterproductive. The term, coined in 1995 by computer programmer Andrew Koenig , was inspired by the book Design Patterns (which highlights a number of design patterns in software development that its authors considered to be highly reliable and effective) and first published in his article in the Journal of Object-Oriented Programming . A further paper in 1996 presented by Michael Ackroyd at the Object World West Conference also documented anti-patterns.

It was, however, the 1998 book AntiPatterns that both popularized the idea and extended its scope beyond the field of software design to include software architecture and project management. Other authors have extended it further since to encompass environmental, organizational, and cultural anti-patterns.

According to the authors of Design Patterns , there are two key elements to an anti-pattern that distinguish it from a bad habit, bad practice, or bad idea:

A guide to what is commonly used is a "rule-of-three" similar to that for patterns: to be an anti-pattern it must have been witnessed occurring at least three times.

Documenting anti-patterns can be an effective way to analyze a problem space and to capture expert knowledge.

While some anti-pattern descriptions merely document the adverse consequences of the pattern, good anti-pattern documentation also provides an alternative, or a means to ameliorate the anti-pattern.

In software engineering, anti-patterns include the big ball of mud (lack of) design, the god object (where a single class handles all control in a program rather than control being distributed across multiple classes), magic numbers (unique values with an unexplained meaning or multiple occurrences which could be replaced with a named constant), and poltergeists (ephemeral controller classes that only exist to invoke other methods on classes).

This indicates a software system that lacks a perceivable architecture. Although undesirable from a software engineering point of view, such systems are common in practice due to business pressures, developer turnover and code entropy .

The term was popularized in Brian Foote and Joseph Yoder's 1997 paper of the same name, which defines the term:

A Big Ball of Mud is a haphazardly structured, sprawling, sloppy, duct-tape-and-baling-wire, spaghetti-code jungle. These systems show unmistakable signs of unregulated growth, and repeated, expedient repair. Information is shared promiscuously among distant elements of the system, often to the point where nearly all the important information becomes global or duplicated.

The overall structure of the system may never have been well defined.

If it was, it may have eroded beyond recognition. Programmers with a shred of architectural sensibility shun these quagmires. Only those who are unconcerned about architecture, and, perhaps, are comfortable with the inertia of the day-to-day chore of patching the holes in these failing dikes, are content to work on such systems.

Foote and Yoder have credited Brian Marick as the originator of the "big ball of mud" term for this sort of architecture.

Project management anti-patterns included in the Antipatterns book include: