Many programming languages and other computer files have a directive , often called include , import , or copy , that causes the contents of the specified file to be inserted into the original file. These included files are called header file s or copybooks . They are often used to define the physical layout of program data, pieces of procedural code, and/or forward declarations while promoting encapsulation and the reuse of code or data.

In computer programming , a header file is a file that allows programmers to separate certain elements of a program's source code into reusable files.  Header files commonly contain forward declarations of classes , subroutines , variables , and other identifiers . Programmers who wish to declare standardized identifiers in more than one source file can place such identifiers in a single header file, which other code can then include whenever the header contents are required. This is to keep the interface in the header separate from the implementation .

The C standard library and the C++ standard library traditionally declare their standard functions in header files.

Some newer compiled languages (such as Java and C# ) do not use forward declarations; identifiers are recognized automatically from source files and read directly from dynamic library symbols. This means header files are not needed.

The include directive allows libraries of code to be developed which help to:

An example situation which benefits from the use of an include directive is when referring to functions in a different file. Suppose there is some C source file containing a function add , which is referred to in a second file by first declaring its external existence and type (with a function prototype ) as follows:

One drawback of this approach is that the function prototype must be present in all files that use the function. Another drawback is that if the return type or arguments of the function are changed, all of these prototypes would need to be updated. Putting the prototype in a single, separate file avoids these issues. Assuming the prototype is moved to the file add.h , the second source file can then become:

Now, every time the code is compiled, the latest function prototypes in add.h will be included in the files using them, avoiding potential errors.

In the C and C++ programming languages, the #include preprocessor directive causes the compiler to replace that line with the entire text of the contents of the named source file (if included in quotes: "") or named header (if included in angle brackets: <>); a header doesn't need to be a source file. Inclusion continues recursively on these included contents, up to an implementation-defined nesting limit. Headers need not have names corresponding to files: in C++ standard headers are typically identified with words, like "vector", hence #include <vector> , while in C standard headers have identifiers in the form of filenames with a ".h" extension, as in #include <stdio.h> . A "source file" can be any file, with a name of any form, but is most commonly named with a ".h" extension and called a "header file" (sometimes ".hpp" or ".hh" to distinguish C++ headers), though files with .c, .cc, and .cpp extensions may also be included (particularly in the single compilation unit technique), and sometimes other extensions are used.

These two forms of #include directive can determine which header or source file to include in an implementation-defined way. In practice, what is usually done is that the angle-brackets form searches for source files in a standard system directory (or set of directories), and then searches for source files in local or project-specific paths (specified on the command line, in an environment variable, or in a Makefile or other build file), while the form with quotes does not search in a standard system directory, only searching in local or project-specific paths. In case there is no clash, the angle-brackets form can also be used to specify project-specific includes, but this is considered poor form. The fact that headers need not correspond to files is primarily an implementation technicality, and is used to omit the .h extension in including C++ standard headers; in common use, "header" means "header file".

For example:

In C and C++, problems may be faced if two (or more) include files contain the same third file. One solution is to avoid include files from including any other files, possibly requiring the programmer to manually add extra include directives to the original file. Another solution is to use include guards .

Since C++20 , headers can also be imported as header units , that is, separate translation units synthesized from a header. They are meant to be used alongside modules . The syntax used in that case is

For example:

Header units are provided for all the C++ standard library headers.

COBOL (and also RPG IV ) allows programmers to copy copybooks into the source of the program in a similar way to header files, but it also allows for the replacement of certain text in them with other text. The COBOL keyword for inclusion is COPY , and replacement is done using the REPLACING ... BY ... clause. An include directive has been present in COBOL since COBOL 60, but changed from the original INCLUDE to COPY by 1968.

Fortran does not require header files per se . However, Fortran 90 and later have two related features: include statements and modules. The former can be used to share a common file containing procedure interfaces, much like a C header, although the specification of an interface is not required for all varieties of Fortran procedures. This approach is not commonly used; instead, procedures are generally grouped into modules that can then be referenced with a use statement within other regions of code. For modules, header-type interface information is automatically generated by the compiler and typically put into separate module files, although some compilers have placed this information directly into object files. The language specification itself does not mandate the creation of any extra files, even though module procedure interfaces are almost universally propagated in this manner.

Most Pascal compilers support the $i or $include compiler directive, in which the $i or $include directive immediately follows the start of a comment block in the form of

Where the $i or $include directive is not case sensitive , and filename.pas or filename.inc is the name of the file to be included. (It has been common practice to name Pascal's include files with the extension .inc , but this is not required.) Some compilers, to prevent unlimited recursion, limit invoking an include file to a certain number, prohibit invoking itself or any currently open file, or are limited to a maximum of one include file at a time, e.g. an include file cannot include itself or another file. However, the program that includes other files can include several, just one at a time.

In PHP , the include directive causes another PHP file to be included and evaluated. Similar commands are require , which upon failure to include will produce a fatal exception and halt the script, and include_once and require_once , which prevent a file from being included or required again if it has already been included or required, avoiding the C's double inclusion problem.

There are many forms of the include directive, such as:

Modern languages (e.g. Haskell and Java ) tend to avoid copybooks or includes, preferring modules and import/export systems for namespace control. Some of these languages (such as Java and C# ) do not use forward declarations and, instead, identifiers are recognized automatically from source files and read directly from dynamic library symbols (typically referenced with import or using directives), meaning header files are not needed.