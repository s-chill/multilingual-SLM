(In the automation and engineering environments, the hardware engineer or architect encompasses the electronics engineering and electrical engineering fields, with subspecialities in analog , digital , or electromechanical systems.)

The hardware systems architect or hardware architect is responsible for:

Large systems architecture was developed as a way to handle systems too large for one person to conceive of, let alone design.  Systems of this size are rapidly becoming the norm, so architectural approaches and architects are increasingly needed to solve the problems of large systems.

Engineers as a group do not have a reputation for understanding and responding to human needs comfortably or for developing humanly functional and aesthetically pleasing products.  Architects are expected to understand human needs and develop humanly functional and aesthetically pleasing products. A good architect is a translator between the user/sponsor and the engineers—and even among just engineers of different specialties.  A good architect is also the principal keeper of the user's vision of the end product—and of the process of deriving requirements from and implementing that vision.

Determining what the users/sponsors actually want, rather than what they say they want, is not engineering—it is an art. An architect does not follow an exact procedure.  S/he communicates with users/sponsors in a highly interactive way—together they extract the true requirements necessary for the engineered system.  The hardware architect must remain constantly in communication with the end users (or a systems architect).  Therefore, the architect must be familiar with the user's environment and problem.  The engineer need only be very knowledgeable of the potential engineering solution space.

The user/sponsor should view the architect as the user's representative and provide all input through the architect. Direct interaction with project engineers is generally discouraged as the chance of mutual misunderstanding is very high.  The user requirements' specification should be a joint product of the user and hardware architect (or, the systems and hardware architects): the user brings his  needs and wish list, the architect brings knowledge of what is likely to prove doable within cost and time constraints.  When the user needs are translated into a set of high level requirements is also the best time to write the first version of the acceptance test , which should, thereafter, be religiously kept up to date with the requirements.  That way, the user will be absolutely clear about what s/he is getting.  It is also a safeguard against untestable requirements, misunderstandings, and requirements creep.

The development of the first level of hardware engineering requirements is not a purely analytical exercise and should also involve both the hardware architect and engineer.  If any compromises are to be made—to meet constraints like cost, schedule, power, or space, the architect must ensure that the final product and overall look and feel do not stray very far from the user's intent.  The engineer should focus on developing a design that optimizes the constraints but ensures a workable and reliable product.  The architect is primarily concerned with the comfort and usability of the product; the engineer is primarily concerned with the producibility and utility of the product.

The provision of needed services to the user is the true function of an engineered system.  However, as systems become ever larger and more complex, and as their  emphases move away from simple hardware components, the narrow application of traditional hardware development principles is found to be insufficient—the application of the more general principles of hardware architecture to the design of (sub) systems is seen to be needed.  A Hardware architecture is also a simplified model of the finished end product—its primary function is to define the hardware components and their relationships to each other so that the whole can be seen to be a consistent, complete, and correct representation of what the user had in mind—especially for the computer–human interface.  It is also used to ensure that the components fit together and relate in the desired way.

It is necessary to distinguish between the architecture of the user's world and the engineered hardware architecture.  The former represents and addresses problems and solutions in the user's world.  It is principally captured in the computer–human interfaces (CHI) of the engineered system.  The engineered system represents the engineering solutions—how the engineer proposes to develop and/or select and combine the components of the technical infrastructure to support the CHI.  In the absence of an architect, there is an unfortunate tendency to confuse the two architectures, since the engineer thinks in terms of hardware, but the user may be thinking in terms of solving a problem of getting people from point A to point B in a reasonable amount of time and with a reasonable expenditure of energy, or of getting needed information to customers and staff. A hardware architect is expected to combine knowledge of both the architecture of the user's world and of (all potentially useful) hardware engineering architectures.  The former is a joint activity with the user; the latter is a joint activity with the engineers.  The product is a set of high level requirements reflecting the user's requirements which can be used by the engineers to develop hardware systems design requirements.

Because requirements evolve over the course of a project, especially a long one, an architect is needed until the hardware system is accepted by the user: the architect is the best insurance that no changes and interpretations made during the course of development compromise the user's viewpoint.

Most hardware engineers are specialists.  They know the applications of hardware design and development intimately, apply their knowledge to practical situations—that is, solve real world problems, evaluate the cost–benefits of various solutions within their hardware specialty, and ensure the correct operation of whatever they design.  Hardware architects are generalists.  They are not expected to be experts in any one hardware technology or approach, but are expected to be knowledgeable of many, and able to judge their applicability to specific situations.  They also apply their knowledge to practical situations, but evaluate the cost/benefits of various solutions using different hardware technologies, for example, specially developed versus commercially available hardware components, and assure that the system as a whole performs according to the user's expectations.

Many commercial-off-the-shelf or already developed hardware components may be selected independently according to constraints such as cost, response, throughput, etc.  In some cases, the architect can already assemble the end system unaided.  Or, s/he may still need the help of a hardware engineer to select components and to design and build any special purpose function.  The architects (or engineers) may also enlist the aid of specialists—in safety, security, communications, special purpose hardware, graphics, human factors, test and evaluation, quality control, RMA, interface management, etc.  An effective hardware architectural team must have immediate access to specialists in critical specialties.

An architect planning a building works on the overall design, making sure it will be pleasing and useful to its inhabitants. While a  single architect by himself may be enough to build a single-family house,  many engineers may be needed, in addition, to solve the detailed problems that arise when a novel high-rise building is designed.  If the job is large and complex enough, parts of the architecture may be designed as components.  That is, if we are building a housing complex, we may have one architect for the complex, and one for each type of building, as part of an architectural team.

Large hardware systems also require an architect and much engineering talent.  If the engineered system is large and complex enough, the chief hardware systems architect may defer to subordinate architects for parts of the job, although they all may be members of a joint architectural team. But the architect must never be viewed as an engineering supervisor.

The architect should sub-allocate the hardware requirements to major components or subsystems that are within the scope of a single hardware engineer, or engineering manager or subordinate architect.  Ideally, each such hardware component/subsystem is a sufficiently stand-alone object that it can be tested as a complete component, separate from the whole, using only a simple testbed to supply simulated inputs and record outputs.  That is, it is not necessary to know how an air traffic control system works in order to design and build a data management subsystem for it.  It is only necessary to know the constraints under which the subsystem will be expected to operate.

A good architect ensures that the system, however complex, is built upon relatively simple and "clean" concepts for each (sub) system or layer—easily understandable by everyone, especially the user, without special training. The architect will use a minimum of rules to ensure that each partition is well-defined and clean of kludges , work-arounds , short-cuts, or confusing detail and exceptions. As user needs evolve, (once the system is fielded and in use), it is a lot easier subsequently to evolve a simple concept than one laden with exceptions, special cases, and much "fine print."

Layering the hardware architecture is important for keeping it sufficiently simple at each layer so that it remains comprehensible to a single mind. As layers are ascended, whole systems at lower layers become simple components at the higher layers, and may disappear altogether at the highest layers.

The acceptance test always remains the principal responsibility of the architect(s).  It is the chief means by which the architect will prove to the user that the hardware is as originally planned and that all subordinate architects and engineers have met their objectives.  Large projects tend to be dynamic, with changes along the way needed by the user (e.g., as his problems change), or expected of the user (e.g., for cost or schedule reasons). But acceptance tests must be kept current at all times. They are the principal means by which the user is kept informed as to how the final product will perform.  And they act as the principal goal towards which all subordinate personnel must design, build and test for.

A building architect uses sketches, models, drawings.  A hardware systems architect should use sketches, models, and prototypes to discuss different solutions and results with the user or system architect, engineers, and subordinate architects.  An early, draft version of the user's manual is invaluable, especially in conjunction with a prototype.  A set of (engineering) requirements as a means of communicating with the users is explicitly to be avoided.  A well written set of requirements, or specification , is intelligible only to the engineering fraternity, much as a legal contract is for lawyers.