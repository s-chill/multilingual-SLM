Maven is a build automation tool used primarily for Java projects. Maven can also be used to build and manage projects written in C# , Ruby , Scala , and other languages. The Maven project is hosted by The Apache Software Foundation , where it was formerly part of the Jakarta Project .

Maven addresses two aspects of building software: how software is built and its dependencies. Unlike earlier tools like Apache Ant , it uses conventions for the build procedure. Only exceptions need to be specified. An XML file describes the software project being built, its dependencies on other external modules and components, the build order, directories, and required plug-ins . It comes with pre-defined targets for performing certain well-defined tasks such as compilation of code and its packaging. Maven dynamically downloads Java libraries and Maven plug-ins from one or more repositories such as the Maven 2 Central Repository, and stores them in a local cache. This local cache of downloaded artifacts can also be updated with artifacts created by local projects. Public repositories can also be updated.

Maven is built using a plugin-based architecture that allows it to make use of any application controllable through standard input. A C / C++ native plugin is maintained for Maven 2.

Alternative technologies like Gradle and sbt as build tools do not rely on XML , but keep the key concepts Maven introduced. With Apache Ivy , a dedicated dependency manager was developed as well that also supports Maven repositories.

Apache Maven has support for reproducible builds .

Maven was created by Jason van Zyl in 2002 and began as a sub-project of Apache Turbine . In 2003 Maven was accepted as a top level Apache Software Foundation project.

Version history:

Maven projects are configured using a Project Object Model (POM) in a pom.xml file.

Example file:

This POM defines a unique identifier for the project ( coordinates ) and a single dependency on the JUnit library. However, that is already enough for building the project and running the unit tests associated with the project. Maven accomplishes this by embracing the idea of Convention over Configuration , that is, Maven provides default values for the project's configuration.

The directory structure of a normal idiomatic Maven project has the following directory entries:

The command mvn package will compile all the Java files, run any tests, and package the deliverable code and resources into target/my-app-1.0.jar (assuming the artifactId is my-app and the version is 1.0.)

Using Maven, the user provides only configuration for the project, while the configurable plug-ins do the actual work of compiling the project, cleaning target directories, running unit tests, generating API documentation and so on. In general, users should not have to write plugins themselves. Contrast this with Ant and make , in which one writes imperative procedures for doing the aforementioned tasks.

A Project Object Model (POM) provides all the configuration for a single project. General configuration covers the project's name, its owner and its dependencies on other projects. One can also configure individual phases of the build process, which are implemented as plugins . For example, one can configure the compiler-plugin to use Java version 1.5 for compilation, or specify packaging the project  even if some unit tests fail.

Larger projects should be divided into several modules, or sub-projects, each with its own POM. One can then write a root POM through which one can compile all the modules with a single command. POMs can also inherit configuration from other POMs. All POMs inherit from the Super POM by default. The Super POM provides default configuration, such as default source directories, default plugins, and so on.

Most of Maven's functionality is in plug-ins . A plugin provides a set of goals that can be executed using the command mvn [plugin-name]:[goal-name] . For example, a Java project can be compiled with the compiler-plugin's compile-goal by running mvn compiler:compile .

There are Maven plugins for building, testing, source control management, running a web server, generating Eclipse project files, and much more. Plugins are introduced and configured in a <plugins>-section of a pom.xml file. Some basic plugins are included in every project by default, and they have sensible default settings.

However, it would be cumbersome if the archetypal build sequence of building, testing and packaging a software project required running each respective goal manually:

Maven's lifecycle concept handles this issue.

Plugins are the primary way to extend Maven. Developing a Maven plugin can be done by extending the org.apache.maven.plugin.AbstractMojo class. Example code and explanation for a Maven plugin to create a cloud-based virtual machine running an application server is given in the article Automate development and management of cloud virtual machines .

The build lifecycle is a list of named phases that can be used to give order to goal execution. One of Maven's three standard lifecycles is the default lifecycle , which includes the following phases, performed in the order listed:

Goals provided by plugins can be associated with different phases of the lifecycle. For example, by default, the goal compiler:compile is associated with the compile phase, while the goal surefire:test is associated with the test phase. When the mvn test command is executed, Maven runs all goals associated with each of the phases up to and including the test phase. In such a case, Maven runs the resources:resources goal associated with the process-resources phase, then compiler:compile , and so on until it finally runs the surefire:test goal.

Maven also has standard phases for cleaning the project and for generating a project site. If cleaning were part of the default lifecycle, the project would be cleaned every time it was built. This is clearly undesirable, so cleaning has been given its own lifecycle.

Standard lifecycles enable users new to a project the ability to accurately build, test and install every Maven project by issuing the single command mvn install . By default, Maven packages the POM file in generated JAR and WAR files. Tools like diet4j can use this information to recursively resolve and run Maven modules at run-time without requiring an "uber"-jar that contains all project code.

A central feature in Maven is dependency management . Maven's dependency-handling mechanism is organized around a coordinate system identifying individual artifacts such as software libraries or modules. The POM example above references the JUnit coordinates as a direct dependency of the project. A project that needs, say, the Hibernate library simply has to declare Hibernate's project coordinates in its POM. Maven will automatically download the dependency and the dependencies that Hibernate itself needs (called transitive dependencies ) and store them in the user's local repository. Maven 2 Central Repository is used by default to search for libraries, but one can configure the repositories to be used (e.g., company-private repositories) within the POM.

The fundamental difference between Maven and Ant is that Maven's design regards all projects as having a certain structure and a set of supported task work-flows (e.g., getting resources from source control, compiling the project, unit testing, etc.). While most software projects in effect support these operations and actually do have a well-defined structure, Maven requires that this structure and the operation implementation details be defined in the POM file. Thus, Maven relies on a convention on how to define projects and on the list of work-flows that are generally supported in all projects.

There are search engines such as The Central Repository Search Engine, which can be used to find out coordinates for different open-source libraries and frameworks.

Projects developed on a single machine can depend on each other through the local repository. The local repository is a simple folder structure that acts both as a cache for downloaded dependencies and as a centralized storage place for locally built artifacts. The Maven command mvn install builds a project and places its binaries in the local repository. Then, other projects can utilize this project by specifying its coordinates in their POMs.

Add-ons to several popular integrated development environments (IDE) targeting the Java programming language exist to provide integration of Maven with the IDE's build mechanism and source editing tools, allowing Maven to compile projects from within the IDE, and also to set the classpath for code completion, highlighting compiler errors, etc.

Examples of popular IDEs supporting development with Maven include:

These add-ons also provide the ability to edit the POM or use the POM to determine a project's complete set of dependencies directly within the IDE.

Some built-in features of IDEs are forfeited when the IDE no longer performs compilation. For example, Eclipse's JDT has the ability to recompile a single Java source file after it has been edited. Many IDEs work with a flat set of projects instead of the hierarchy of folders preferred by Maven. This complicates the use of SCM systems in IDEs when using Maven.