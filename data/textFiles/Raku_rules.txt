Raku rules are the regular expression , string matching and general-purpose parsing facility of the Raku programming language, and are a core part of the language. Since Perl 's pattern-matching constructs have exceeded the capabilities of formal regular expressions for some time, Raku documentation refers to them exclusively as regexes , distancing the term from the formal definition.

Raku provides a superset of Perl 5 features with respect to regexes, folding them into a larger framework called rules , which provide the capabilities of a parsing expression grammar , as well as acting as a closure with respect to their lexical scope. Rules are introduced with the rule keyword, which has a usage quite similar to subroutine definitions. Anonymous rules can be introduced with the regex (or rx ) keyword, or simply be used inline as regexes were in Perl 5 via the m (matching) or s (substitution) operators.

In Apocalypse 5 , a document outlining the preliminary design decisions for Raku pattern matching, Larry Wall enumerated 20 problems with the "current regex culture". Among these were that Perl's regexes were "too compact and 'cute'", had "too much reliance on too few metacharacters", "little support for named captures", "little support for grammars", and "poor integration with 'real' language".

Between late 2004 and mid-2005, a compiler for Raku style rules was developed for the Parrot virtual machine called Parrot Grammar Engine (PGE), which was later renamed to the more generic Parser Grammar Engine . PGE is a combination of runtime and compiler for Raku style grammars that allows any parrot-based compiler to use these tools for parsing, and also to provide rules to their runtimes.

Among other Raku features, support for named captures was added to Perl 5.10 in 2007.

In May 2012, the reference implementation of Raku, Rakudo , shipped its Rakudo Star monthly snapshot with a working JSON parser built entirely in Raku rules.

There are only six unchanged features from Perl 5's regexes:

A few of the most powerful additions include:

The following changes greatly improve the readability of regexes:

Some of the features of Perl 5 regular expressions are more powerful in Raku because of their ability to encapsulate the expanded features of Raku rules. For example, in Perl 5, there were positive and negative lookahead operators (?=...) and (?!...) . In Raku these same features exist, but are called <before ...> and <!before ...> .

However, because before can encapsulate arbitrary rules, it can be used to express lookahead as a syntactic predicate for a grammar. For example, the following parsing expression grammar describes the classic non-context-free language { a n b n c n : n â‰¥ 1 } {\displaystyle \{a^{n}b^{n}c^{n}:n\geq 1\}} :

In Raku rules that would be:

Of course, given the ability to mix rules and regular code, that can be simplified even further:

However, this makes use of assertions , which is a subtly different concept in Raku rules, but more substantially different in parsing theory, making this a semantic rather than syntactic predicate. The most important difference in practice is performance. There is no way for the rule engine to know what conditions the assertion may match, so no optimization of this process can be made.

In many languages, regular expressions are entered as strings, which are then passed to library routines that parse and compile them into an internal state. In Perl 5, regular expressions shared some of the lexical analysis with Perl's scanner. This simplified many aspects of regular expression usage, though it added a great deal of complexity to the scanner. In Raku, rules are part of the grammar of the language. No separate parser exists for rules, as it did in Perl 5. This means that code, embedded in rules, is parsed at the same time as the rule itself and its surrounding code. For example, it is possible to nest rules and code without re-invoking the parser:

The above is a single block of Raku code that contains an outer rule definition, an inner block of assertion code, and inside of that a regex that contains one more level of assertion.

There are several keywords used in conjunction with Raku rules:

Here is an example of typical use:

Modifiers may be placed after any of the regex keywords, and before the delimiter. If a regex is named, the modifier comes after the name. Modifiers control the way regexes are parsed and how they behave. They are always introduced with a leading : character.

Some of the more important modifiers include:

For example:

A grammar may be defined using the grammar operator. A grammar is essentially just a namespace for rules:

This is the grammar used to define Perl's sprintf string formatting notation.

Outside of this namespace, you could use these rules like so:

A rule used in this way is actually identical to the invocation of a subroutine with the extra semantics and side-effects of pattern matching (e.g., rule invocations can be backtracked).

Here are some example rules in Raku:

That last is identical to: