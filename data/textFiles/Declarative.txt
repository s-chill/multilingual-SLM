In computer science , declarative programming is a programming paradigm —a style of building the structure and elements of computer programs—that expresses the logic of a computation without describing its control flow .

Many languages that apply this style attempt to minimize or eliminate side effects by describing what the program must accomplish in terms of the problem domain , rather than describing how to accomplish it as a sequence of the programming language primitives (the how being left up to the language's implementation ). This is in contrast with imperative programming , which implements algorithms in explicit steps.

Declarative programming often considers programs as theories of a formal logic , and computations as deductions in that logic space. Declarative programming may greatly simplify writing parallel programs .

Common declarative languages include those of database query languages (e.g., SQL , XQuery ), regular expressions , logic programming (e.g. Prolog , Datalog , answer set programming ), functional programming , configuration management , and algebraic modeling systems.

Declarative programming is often defined as any style of programming that is not imperative. A number of other common definitions attempt to define it by simply contrasting it with imperative programming. For example:

These definitions overlap substantially.

Declarative programming is a non-imperative style of programming in which programs describe their desired results without explicitly listing commands or steps that must be performed. Functional and logic programming languages are characterized by a declarative programming style. In logic programming, programs consist of sentences expressed in logical form, and computation uses those sentences to solve problems, which are also expressed in logical form.

In a pure functional language , such as Haskell , all functions are without side effects , and state changes are only represented as functions that transform the state, which is explicitly represented as a first-class object in the program. Although pure functional languages are non-imperative, they often provide a facility for describing the effect of a function as a series of steps. Other functional languages, such as Lisp , OCaml and Erlang , support a mixture of procedural and functional programming.

Some logic programming languages, such as Prolog , and database query languages, such as SQL, while declarative in principle, also support a procedural style of programming.

Declarative programming is an umbrella term that includes a number of better-known programming paradigms .

Constraint programming states relations between variables in the form of constraints that specify the properties of the target solution. The set of constraints is solved by giving a value to each variable so that the solution is consistent with the maximum number of constraints. Constraint programming often complements other paradigms: functional, logical, or even imperative programming.

Well-known examples of declarative domain-specific languages (DSLs) include the yacc parser generator input language, QML , the Make build specification language, Puppet 's configuration management language, regular expressions , Datalog , answer set programming and a subset of SQL (SELECT queries, for example). DSLs have the advantage of being useful while not necessarily needing to be Turing-complete , which makes it easier for a language to be purely declarative.

Many markup languages such as HTML , MXML , XAML , XSLT or other user-interface markup languages are often declarative. HTML, for example, only describes what should appear on a webpage - it specifies neither control flow for rendering a page nor the page's possible interactions with a user .

As of 2013 , some software systems combine traditional user-interface markup languages (such as HTML) with declarative markup that defines what (but not how) the back-end server systems should do to support the declared interface. Such systems, typically using a domain-specific XML namespace , may include abstractions of SQL database syntax or parameterized calls to web services using representational state transfer (REST) and SOAP .

Functional programming languages such as Haskell , Scheme , and ML evaluate expressions via function application. Unlike the related but more imperative paradigm of procedural programming , functional programming places little emphasis on explicit sequencing. Instead, computations are characterised by various kinds of recursive higher-order function application and composition , and as such can be regarded simply as a set of mappings between domains and codomains . Many functional languages, including most of those in the ML and Lisp families, are not purely functional , and thus allow the introduction of stateful effects in programs.

Makefiles, for example, specify dependencies in a declarative fashion, but include an imperative list of actions to take as well. Similarly, yacc specifies a context free grammar declaratively, but includes code snippets from a host language, which is usually imperative (such as C ).

Logic programming languages, such as Prolog , Datalog and answer set programming , compute by proving that a goal is a logical consequence of the program, or by showing that the goal is true in a model defined by the program. Prolog computes by reducing goals to subgoals, top-down using backward reasoning , whereas most Datalog systems compute bottom-up using forward reasoning . Answer set programs typically use SAT solvers to generate a model of the program.

Models, or mathematical representations, of physical systems may be implemented in computer code that is declarative. The code contains a number of equations, not imperative assignments, that describe ("declare") the behavioral relationships. When a model is expressed in this formalism, a computer is able to perform algebraic manipulations to best formulate the solution algorithm. The mathematical causality is typically imposed at the boundaries of the physical system, while the behavioral description of the system itself is declarative or acausal. Declarative modeling languages and environments include Analytica , Modelica and Simile .

Lisp is a family of programming languages loosely inspired by mathematical notation and Alonzo Church 's lambda calculus . Some dialects, such as Common Lisp , are primarily imperative but support functional programming. Others, such as Scheme , are designed for functional programming.

In Scheme, the factorial function can be defined as follows:

This defines the factorial function using its recursive definition. In contrast, it is more typical to define a procedure for an imperative language.

In lisps and lambda calculus, functions are generally first-class citizens . Loosely, this means that functions can be inputs and outputs for other functions. This can simplify the definition of some functions.

For example, writing a function to output the first n square numbers in Racket can be done accordingly:

The map function accepts a function and a list; the output is a list of results of the input function on each element of the input list.

ML (1973) stands for "Meta Language." ML is statically typed, and function arguments and return types may be annotated.

ML is not as bracket-centric as Lisp , and instead uses a wider variety of syntax to codify the relationship between code elements, rather than appealing to list ordering and nesting to express everything. The following is an application of times_10 :

It returns "20 : int", that is, 20 , a value of type int .

Like Lisp , ML is tailored to process lists, though all elements of a list must be the same type.

Prolog (1972) stands for "PROgramming in LOGic." It was developed for natural language question answering , using SL resolution both to deduce answers to queries and to parse and generate natural language sentences.

The building blocks of a Prolog program are facts and rules . Here is a simple example:

Given this program, the query eat ( tom , jerry ) succeeds, while eat ( jerry , tom ) fails. Moreover, the query eat ( X , jerry ) succeeds with the answer substitution X = tom .

Prolog executes programs top-down, using SLD resolution to reason backwards , reducing goals to subgoals. In this example, it uses the last rule of the program to reduce the goal of answering the query eat ( X , jerry ) to the subgoals of first finding an X such that big ( X ) holds and then of showing that small ( jerry ) holds. It repeatedly uses rules to further reduce subgoals to other subgoals, until it eventually succeeds in unifying all subgoals with facts in the program. This backward reasoning, goal-reduction strategy treats rules in logic programs as procedures, and makes Prolog both a declarative and procedural programming language.

The broad range of Prolog applications is highlighted in the Year of Prolog Book, celebrating the 50 year anniversary of Prolog.

The origins of Datalog date back to the beginning of logic programming, but it was identified as a separate area around 1977. Syntactically and semantically , it is a subset of Prolog. But because it does not have compound terms , it is not Turing-complete .

Most Datalog systems execute programs bottom-up, using rules to reason forwards , deriving new facts from existing facts, and terminating when there are no new facts that can be derived, or when the derived facts unify with the query. In the above example, a typical Datalog system would first derive the new facts:

Using these facts, it would then derive the additional fact:

It would then terminate, both because no new, additional facts can be derived, and because the newly derived fact unifies with the query

Datalog has been applied to such problems as data integration , information extraction , networking , security , cloud computing and machine learning .

Answer set programming (ASP) evolved in the late 1990s, based on the stable model (answer set) semantics of logic programming. Like Datalog, it is a subset of Prolog; and, because it does not have compound terms, it is not Turing-complete.

Most implementations of ASP execute a program by first "grounding" the program, replacing all variables in rules by constants in all possible ways, and then using a propositional SAT solver, such as the DPLL algorithm to generate one or more models of the program.

Its applications are oriented towards solving difficult search problems and knowledge representation .