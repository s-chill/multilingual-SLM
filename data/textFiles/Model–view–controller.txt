Model–view–controller ( MVC ) is a software design pattern commonly used for developing user interfaces that divides the related program logic into three interconnected elements. These elements are:

Traditionally used for desktop graphical user interfaces (GUIs), this pattern became popular for designing web applications . Popular programming languages have MVC frameworks that facilitate the implementation of the pattern.

One of the seminal insights in the early development of graphical user interfaces, MVC became one of the first approaches to describe and implement software constructs in terms of their responsibilities .

Trygve Reenskaug created MVC while working on Smalltalk -79 as a visiting scientist at the Xerox Palo Alto Research Center (PARC) in the late 1970s. He wanted a pattern that could be used to structure any program where users interact with a large, convoluted data set . His design initially had four parts: Model , view, thing, and editor. After discussing it with the other Smalltalk developers , he and the rest of the group settled on model, view, and controller instead.

In their final design, a model represents some part of the program purely and intuitively. A view is a visual representation of a model, retrieving data from the model to display to the user and passing requests back and forth between the user and the model. A controller is an organizational part of the user interface that lays out and coordinates multiple Views on the screen, and which receives user input and sends the appropriate messages to its underlying Views. This design also includes an Editor as a specialized kind of controller used to modify a particular view, and which is created through that view.

Smalltalk-80 supports a version of MVC that evolved from this one. It provides abstract view and controller classes as well as various concrete subclasses of each that represent different generic widgets . In this scheme, a View represents some way of displaying information to the user, and a controller represents some way for the user to interact with a view . A view is also coupled to a model object, but the structure of that object is left up to the application programmer . The Smalltalk-80 environment also includes an "MVC Inspector", a development tool for viewing the structure of a given model, view, and controller side-by-side.

In 1988, an article in The Journal of Object Technology (JOT) by two ex-PARC employees presented MVC as a general " programming paradigm and methodology" for Smalltalk-80 developers. However, their scheme differed from both Reenskaug et al.'s and that presented by the Smalltalk-80 reference books. They defined a view as covering any graphical concern, with a controller being a more abstract, generally invisible object that receives user input and interacts with one or many views and only one model.

The MVC pattern subsequently evolved, giving rise to variants such as hierarchical model–view–controller (HMVC), model–view–adapter (MVA), model–view–presenter (MVP), model–view–viewmodel (MVVM), and others that adapted MVC to different contexts.

The use of the MVC pattern in web applications grew after the introduction of NeXT 's WebObjects in 1996, which was originally written in Objective-C (that borrowed heavily from Smalltalk) and helped enforce MVC principles. Later, the MVC pattern became popular with Java developers when WebObjects was ported to Java . Later frameworks for Java, such as Spring (released in October 2002), continued the strong bond between Java and MVC.

In 2003, Martin Fowler published Patterns of Enterprise Application Architecture , which presented MVC as a pattern where an "input controller" receives a request, sends the appropriate messages to a model object, takes a response from the model object, and passes the response to the appropriate view for display. This is close to the approach taken by the Ruby on Rails web application framework (August 2004), which has the client send requests to the server via an in- browser view, these requests are handled by a controller on the server, and the controller communicates with the appropriate model objects. The Django framework (July 2005, for Python ) put forward a similar "model template view" (MTV) take on the pattern, in which a view retrieves data from models and passes it to templates for display. Both Rails and Django debuted with a strong emphasis on rapid deployment, which increased MVC's popularity outside the traditional enterprise environment in which it has long been popular.

The central component of the pattern. It is the application's dynamic data structure , independent of the user interface. It directly manages the data, logic and rules of the application. In Smalltalk-80, the design of a model type is left entirely to the programmer. With WebObjects, Rails, and Django, a model type typically represents a table in the application's database . The model is essential for keeping the data organized and consistent. It ensures that the application's data behaves according to the defined rules and logic.

Any representation of information such as a chart , diagram or table. Multiple views of the same information are possible, such as a bar chart for management and a tabular view for accountants .

In Smalltalk-80, a view is just a visual representation of a model, and does not handle user input. With WebObjects, a view represents a complete user interface element such as a menu or button, and does receive input from the user. In both Smalltalk-80 and WebObjects, however, views are meant to be general-purpose and composable .

With Rails and Django, the role of the view is played by HTML templates, so in their scheme a view specifies an in-browser user interface rather than representing a user interface widget directly. (Django opts to call this kind of object a "template" in light of this. ) This approach puts relatively less emphasis on small, composable views; a typical Rails view has a one-to-one relationship with a controller action.

Smalltalk-80 views communicate with both a model and a controller, whereas with WebObjects, a view talks only to a controller, which then talks to a model. With Rails and Django, a view/template is used by a controller/view when preparing a response to the client.

Accepts input and converts it to commands for the model or view.

A Smalltalk-80 controller handles user input events, such as button presses or mouse movement. At any given time, each controller has one associated view and model, although one model object may hear from many different controllers. Only one controller, the "active" controller, receives user input at any given time; a global window manager object is responsible for setting the current active controller. If user input prompts a change in a model, the controller will signal the model to change, but the model is then responsible for telling its views to update.

In WebObjects, the views handle user input, and the controller mediates between the views and the models. There may be only one controller per application, or one controller per window. Much of the application-specific logic is found in the controller.

In Rails, requests arriving at the on-server application from the client are sent to a " router ", which maps the request to a specific method of a specific controller. Within that method, the controller interacts with the request data and any relevant model objects and prepares a response using a view. Conventionally, each view has an associated controller; for example, if the application had a client view, it would typically have an associated Clients controller as well. However, developers are free to make other kinds of controllers if they wish.

Django calls the object playing this role a "view" instead of a controller. A Django view is a function that receives a web request and returns a web response. It may use templates to create the response.

In addition to dividing the application into a model, a view and a controller component, the MVC design pattern defines the interactions between these three components :

As with other software patterns, MVC expresses the "core of the solution" to a problem while allowing it to be adapted for each system. Particular MVC designs can vary significantly from the traditional description here.

As Alan Kay wrote in 2003, the original motivation behind the MVC was to allow creation of a graphical interface for any object. That was outlined in detail in Richard Pawson's book Naked Objects .

Trygve Reenskaug, originator of MVC at PARC, has written that "MVC was conceived as a general solution to the problem of users controlling a large and complex data set."

In their 1991 guide Inside Smalltalk , Carleton University computer science professors Wilf LaLonde and John Pugh described the advantages of Smalltalk-80-style MVC as:

Although originally developed for desktop computing , MVC has been widely adopted as a design for World Wide Web applications in major programming languages . Several web frameworks have been created that enforce the pattern. These software frameworks vary in their interpretations, mainly in the way that the MVC responsibilities are divided between the client and server . Early MVC frameworks took a thin client approach that placed almost the entire model, view and controller logic on the server. In this approach, the client sends hyperlink requests or form submissions to the controller and then receives a complete and updated web page (or other document) from the view; the model exists entirely on the server. Later frameworks have allowed the MVC components to execute partly on the client, using Ajax to synchronize data.