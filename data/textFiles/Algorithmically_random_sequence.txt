Intuitively, an algorithmically random sequence (or random sequence ) is a sequence of binary digits that appears random to any algorithm running on a (prefix-free or not) universal Turing machine .  The notion can be applied analogously to sequences on any finite alphabet (e.g. decimal digits). Random sequences are key objects of study in algorithmic information theory .

In measure-theoretic probability theory , introduced by Andrey Kolmogorov in 1933, there is no such thing as a random sequence. For example, consider flipping a fair coin infinitely many times. Any particular sequence, be it 0000 … {\displaystyle 0000\dots } or 011010 … {\displaystyle 011010\dots } , has equal probability of exactly zero. There is no way to state that one sequence is "more random" than another sequence, using the language of measure-theoretic probability. However, it is intuitively obvious that 011010 … {\displaystyle 011010\dots } looks more random than 0000 … {\displaystyle 0000\dots } . Algorithmic randomness theory formalizes this intuition.

As different types of algorithms are sometimes considered, ranging from algorithms with specific bounds on their running time to algorithms which may ask questions of an oracle machine , there are different notions of randomness. The most common of these is known as Martin-Löf randomness ( K-randomness or 1-randomness ), but stronger and weaker forms of randomness also exist. When the term "algorithmically random" is used to refer to a particular single (finite or infinite) sequence without clarification, it is usually taken to mean "incompressible" or, in the case the sequence is infinite and prefix algorithmically random (i.e., K-incompressible), "Martin-Löf–Chaitin random".

Since its inception, Martin-Löf randomness has been shown to admit many equivalent characterizations—in terms of compression , randomness tests, and gambling —that bear little outward resemblance to the original definition, but each of which satisfy our intuitive notion of properties that random sequences ought to have: random sequences should be incompressible, they should pass statistical tests for randomness, and it should be difficult to make money betting on them. The existence of these multiple definitions of Martin-Löf randomness, and the stability of these definitions under different models of computation, give evidence that Martin-Löf randomness is a fundamental property of mathematics and not an accident of Martin-Löf's particular model.

It is important to disambiguate between algorithmic randomness and stochastic randomness. Unlike algorithmic randomness, which is defined for computable (and thus deterministic) processes, stochastic randomness is usually said to be a property of a sequence that is a priori known to be generated by (or is the outcome of) an independent identically distributed equiprobable stochastic process.

Because infinite sequences of binary digits can be identified with real numbers in the unit interval, random binary sequences are often called (algorithmically) random real numbers . Additionally, infinite binary sequences correspond to characteristic functions of sets of natural numbers; therefore those sequences might be seen as sets of natural numbers.

The class of all Martin-Löf random (binary) sequences is denoted by RAND or MLR.

Richard von Mises formalized the notion of a test for randomness in order to define a random sequence as one that passed all tests for randomness. He defined a "collective" ( kollektiv ) to be an infinite binary string x 1 : ∞ {\displaystyle x_{1:\infty }} defined such that

To pick out a subsequence, first pick a binary function ϕ {\displaystyle \phi } , such that given any binary string x 1 : k {\displaystyle x_{1:k}} , it outputs either 0 or 1. If it outputs 1, then we add x k + 1 {\displaystyle x_{k+1}} to the subsequence, else we continue. In this definition, some admissible rules might abstain forever on some sequences, and thus fail to pick out an infinite subsequence. We only consider those that do pick an infinite subsequence.

Stated in another way, each infinite binary string is a coin-flip game, and an admissible rule is a way for a gambler to decide when to place bets. A collective is a coin-flip game where there is no way for one gambler to do better than another over the long run. That is, there is no gambling system that works for the game.

The definition generalizes from binary alphabet to countable alphabet:

Usually the admissible rules are defined to be rules computable by a Turing machine, and we require p = 1 / 2 {\displaystyle p=1/2} . With this, we have the Mises–Wald–Church random sequences . This is not a restriction, since given a sequence with p = 1 / 2 {\displaystyle p=1/2} , we can construct random sequences with any other computable p ∈ ( 0 , 1 ) {\displaystyle p\in (0,1)} . Here, "Church" refers to Alonzo Church , whose 1940 paper proposed using Turing-computable rules.

Theorem. ( Abraham Wald , 1936, 1937) If there are only countably many admissible rules, then almost any sequence is a collective.

Proof sketch: Use measure-theoretic probability.

Fix one admissible rule. Sample a random sequence from Bernoulli space. With probability 1 (use martingales), the subsequence picked by the admissible rule still has lim n 1 n ∑ i = 1 n x m i = p {\displaystyle \lim _{n}{\frac {1}{n}}\sum _{i=1}^{n}x_{m_{i}}=p} . Now add all the countably many rules. With probability 1, each subsequence picked by each rule still has lim n 1 n ∑ i = 1 n x m i = p {\displaystyle \lim _{n}{\frac {1}{n}}\sum _{i=1}^{n}x_{m_{i}}=p} .

Counterexample. (Jean Ville, 1939) If there are only countably many admissible rules, then there exists a collective with 1 n ∑ k = 1 n x k ≥ p {\displaystyle {\frac {1}{n}}\sum _{k=1}^{n}x_{k}\geq p} for all n {\displaystyle n} .

Proof: See.

Intuitively, the long-time average of a random sequence should oscillate on both sides of p {\displaystyle p} , like how a random walk should cross the origin infinitely many times. The counterexample suggests that the von Mises definition is not strong enough.

The Ville counterexample suggests that the Mises–Wald–Church sense of randomness is not good enough, because some random sequences do not satisfy some laws of randomness. For example, the Ville counterexample does not satisfy one of the laws of the iterated logarithm : lim sup n → ∞ − ∑ k = 1 n ( x k − 1 / 2 ) 2 n log ⁡ log ⁡ n ≠ 1 {\displaystyle \limsup _{n\to \infty }{\frac {-\sum _{k=1}^{n}(x_{k}-1/2)}{\sqrt {2n\log \log n}}}\neq 1} Naively, one can fix this by requiring a sequence to satisfy all possible laws of randomness, where a "law of randomness" is a property that is satisfied by all sequences with probability 1. However, for each infinite sequence y 1 : ∞ ∈ 2 N {\displaystyle y_{1:\infty }\in 2^{\mathbb {N} }} , we have a law of randomness that x 1 : ∞ ≠ y 1 : ∞ {\displaystyle x_{1:\infty }\neq y_{1:\infty }} , leading to the conclusion that there are no random sequences.

( Per Martin-Löf , 1966) defined "Martin-Löf randomness" by only allowing laws of randomness that are Turing-computable. In other words, a sequence is random iff it passes all Turing-computable tests of randomness.

The thesis that the definition of Martin-Löf randomness "correctly" captures the intuitive notion of randomness has been called the Martin-Löf–Chaitin Thesis ; it is somewhat similar to the Church–Turing thesis .

Martin-Löf–Chaitin Thesis. The mathematical concept of "Martin-Löf randomness" captures the intuitive notion of an infinite sequence being "random". Church–Turing thesis. The mathematical concept of "computable by Turing machines" captures the intuitive notion of a function being "computable".

Like how Turing-computability has many equivalent definitions, Martin-Löf randomness also has many equivalent definitions. See next section.

Martin-Löf's original definition of a random sequence was in terms of constructive null covers; he defined a sequence to be random if it is not contained in any such cover. Gregory Chaitin , Leonid Levin and Claus-Peter Schnorr proved a characterization in terms of algorithmic complexity :  a sequence is random if there is a uniform bound on the compressibility of its initial segments.   Schnorr gave a third equivalent definition in terms of martingales .  Li and Vitanyi's book An Introduction to Kolmogorov Complexity and Its Applications is the standard introduction to these ideas.

The Kolmogorov complexity characterization conveys the intuition that a random sequence is incompressible: no prefix can be produced by a program much shorter than the prefix.

The null cover characterization conveys the intuition that a random real number should not have any property that is "uncommon".  Each measure 0 set can be thought of as an uncommon property. It is not possible for a sequence to lie in no measure 0 sets, because each one-point set has measure 0.  Martin-Löf's idea was to limit the definition to measure 0 sets that are effectively describable; the definition of an effective null cover determines a countable collection of effectively describable measure 0 sets and defines a sequence to be random if it does not lie in any of these particular measure 0 sets.   Since the union of a countable collection of measure 0 sets has measure 0, this definition immediately leads to the theorem that there is a measure 1 set of random sequences. Note that if we identify the Cantor space of binary sequences with the interval [0,1] of real numbers, the measure on Cantor space agrees with Lebesgue measure .

An effective measure 0 set can be interpreted as a Turing machine that is able to tell, given an infinite binary string, whether the string looks random at levels of statistical significance. The set is the intersection of shrinking sets U 1 ⊃ U 2 ⊃ U 3 ⊃ ⋯ {\displaystyle U_{1}\supset U_{2}\supset U_{3}\supset \cdots } , and since each set U n {\displaystyle U_{n}} is specified by an enumerable sequence of prefixes, given any infinite binary string, if it is in U n {\displaystyle U_{n}} , then the Turing machine can decide in finite time that the string does fall inside U n {\displaystyle U_{n}} . Therefore, it can "reject the hypothesis that the string is random at significance level 2 − n {\displaystyle 2^{-n}} ". If the Turing machine can reject the hypothesis at all significance levels, then the string is not random. A random string is one that, for each Turing-computable test of randomness, manages to remain forever un-rejected at some significance level.

The martingale characterization conveys the intuition that no effective procedure should be able to make money betting against a random sequence.   A martingale d is a betting strategy. d reads a finite string w and bets money on the next bit. It bets some fraction of its money that the next bit will be 0, and then remainder of its money that the next bit will be 1. d doubles the money it placed on the bit that actually occurred, and it loses the rest. d ( w ) is the amount of money it has after seeing the string w . Since the bet placed after seeing the string w can be calculated from the values d ( w ), d ( w 0), and d ( w 1), calculating the amount of money it has is equivalent to calculating the bet. The martingale characterization says that no betting strategy implementable by any computer (even in the weak sense of constructive strategies, which are not necessarily computable ) can make money betting on a random sequence.

There is a universal constructive martingale d . This martingale is universal in the sense that, given any constructive martingale d , if d succeeds on a sequence, then d succeeds on that sequence as well. Thus, d succeeds on every sequence in RAND (but, since d is constructive, it succeeds on no sequence in RAND). (Schnorr 1971)

There is a constructive null cover of RAND . This means that all effective tests for randomness (that is,  constructive null covers) are, in a sense, subsumed by this universal test for randomness, since any sequence that passes this single test for randomness will pass all tests for randomness. (Martin-Löf 1966) Intuitively, this universal test for randomness says "If the sequence has increasingly long prefixes that can be increasingly well-compressed on this universal Turing machine", then it is not random." -- see next section.

Construction sketch: Enumerate the effective null covers as ( ( U m , n ) n ) m {\displaystyle ((U_{m,n})_{n})_{m}} . The enumeration is also effective (enumerated by a modified universal Turing machine). Now we have a universal effective null cover by diagonalization: ( ∪ n U n , n + k + 1 ) k {\displaystyle (\cup _{n}U_{n,n+k+1})_{k}} .

If a sequence fails an algorithmic randomness test, then it is algorithmically compressible. Conversely, if it is algorithmically compressible, then it fails an algorithmic randomness test.

Construction sketch: Suppose the sequence fails a randomness test, then it can be compressed by lexicographically enumerating all sequences that fails the test, then code for the location of the sequence in the list of all such sequences. This is called "enumerative source encoding".

Conversely, if the sequence is compressible, then by the pigeonhole principle, only a vanishingly small fraction of sequences are like that, so we can define a new test for randomness by "has a compression by this universal Turing machine". Incidentally, this is the universal test for randomness.

For example, consider a binary sequence sampled IID from the Bernoulli distribution. After taking a large number N {\displaystyle N} of samples, we should have about M ≈ p N {\displaystyle M\approx pN} ones. We can code for this sequence as "Generate all binary sequences with length N {\displaystyle N} , and M {\displaystyle M} ones. Of those, the i {\displaystyle i} -th sequence in lexicographic order.".

By Stirling approximation , log 2 ⁡ ( N p N ) ≈ N H ( p ) {\displaystyle \log _{2}{\binom {N}{pN}}\approx NH(p)} where H {\displaystyle H} is the binary entropy function . Thus, the number of bits in this description is: 2 ( 1 + ϵ ) log 2 ⁡ N + ( 1 + ϵ ) N H ( p ) + O ( 1 ) {\displaystyle 2(1+\epsilon )\log _{2}N+(1+\epsilon )NH(p)+O(1)} The first term is for prefix-coding the numbers N {\displaystyle N} and M {\displaystyle M} . The second term is for prefix-coding the number i {\displaystyle i} . (Use Elias omega coding .) The third term is for prefix-coding the rest of the description.
When N {\displaystyle N} is large, this description has just ∼ H ( p ) N {\displaystyle \sim H(p)N} bits, and so it is compressible, with compression ratio ∼ H ( p ) {\displaystyle \sim H(p)} . In particular, the compression ratio is exactly one (incompressible) only when p = 1 / 2 {\displaystyle p=1/2} . (Example 14.2.8 )

Consider a casino offering fair odds at a roulette table. The roulette table generates a sequence of random numbers. If this sequence is algorithmically random, then there is no lower semi-computable strategy to win, which in turn implies that there is no computable strategy to win. That is, for any gambling algorithm, the long-term log-payoff is zero (neither positive nor negative). Conversely, if this sequence is not algorithmically random, then there is a lower semi-computable strategy to win.

As each of the equivalent definitions of a Martin-Löf random sequence is based on what is computable by some Turing machine, one can naturally ask what is computable by a Turing oracle machine . For a fixed oracle A , a sequence B which is not only random but in fact, satisfies the equivalent definitions for computability relative to A (e.g., no martingale which is constructive relative to the oracle A succeeds on B ) is said to be random relative to A . Two sequences, while themselves random, may contain very similar information, and therefore neither will be random relative to the other. Any time there is a Turing reduction from one sequence to another, the second sequence cannot be random relative to the first, just as computable sequences are themselves nonrandom; in particular, this means that Chaitin's Ω is not random relative to the halting problem .

An important result relating to relative randomness is van Lambalgen 's theorem, which states that if C is the sequence composed from A and B by interleaving the first bit of A , the first bit of B , the second bit of A , the second bit of B , and so on, then C is algorithmically random if and only if A is algorithmically random, and B is algorithmically random relative to A . A closely related consequence is that if A and B are both random themselves, then A is random relative to B if and only if B is random relative to A .

Relative randomness gives us the first notion which is stronger than Martin-Löf randomness, which is randomness relative to some fixed oracle A . For any oracle, this is at least as strong, and for most oracles, it is strictly stronger, since there will be Martin-Löf random sequences which are not random relative to the oracle A . Important oracles often considered are the halting problem, ∅ ′ {\displaystyle \emptyset '} , and the n th jump oracle, ∅ ( n ) {\displaystyle \emptyset ^{(n)}} , as these oracles are able to answer specific questions which naturally arise. A sequence which is random relative to the oracle ∅ ( n − 1 ) {\displaystyle \emptyset ^{(n-1)}} is called n -random; a sequence is 1-random, therefore, if and only if it is Martin-Löf random. A sequence which is n -random for every n is called arithmetically random. The n -random sequences sometimes arise when considering more complicated properties. For example, there are only countably many Δ 2 0 {\displaystyle \Delta _{2}^{0}} sets, so one might think that these should be non-random. However, the halting probability Ω is Δ 2 0 {\displaystyle \Delta _{2}^{0}} and 1-random; it is only after 2-randomness is reached that it is impossible for a random set to be Δ 2 0 {\displaystyle \Delta _{2}^{0}} .

Additionally, there are several notions of randomness which are weaker than Martin-Löf randomness. Some of these are weak 1-randomness, Schnorr randomness, computable randomness, partial computable randomness. Yongge Wang showed that Schnorr randomness is different from computable randomness. Additionally, Kolmogorov–Loveland randomness is known to be no stronger than Martin-Löf randomness, but it is not known whether it is actually weaker.

At the opposite end of the randomness spectrum there is the notion of a K-trivial set . These sets are anti-random in that all initial segment is logarithmically compressible (i.e., K ( w ) ≤ K ( | w | ) + b {\displaystyle K(w)\leq K(|w|)+b} for each initial segment w), but they are not computable.