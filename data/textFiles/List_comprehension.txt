List comprehension is a syntactic construct available in some programming languages for creating a list based on existing lists.  It follows the form of the mathematical set-builder notation ( set comprehension ) as distinct from the use of map and filter functions.

List with all the doubles from 0 to 10 (exclusive)

List with the names of the customers based in Rio de Janeiro

The previous code is syntactic sugar for the following code written using lambda expressions:

Filtering numbers divisible by 3:

Multiple "generators":

An infinite lazy sequence:

A list comprehension using multiple generators:

List comprehensions can be expressed with the loop macro's collect keyword. Conditionals are expressed with if , as follows:

List the names of customers:

List the customers with balances:

List the names of customers with balances:

The general forms:

Note that by putting the condition and expression after the variable name and enumerable object, editors and IDEs can provide autocompletion on the members of the variable.

Lazily-evaluated sequences:

Or, for floating point values

Lists and arrays:

List comprehensions are the part of a greater family of language constructs called computation expressions.

An example of a list comprehension using multiple generators:

By using Range object, Io language can create list as easy as in other languages:

List comprehensions can be expressed with the for special form. Conditionals are expressed with if , as follows:

Julia supports comprehensions using the syntax:

and multidimensional comprehensions like:

It is also possible to add a condition:

And just changing square brackets to the round one, we get a generator:

Multiple generators:

Nim has built-in seq, set, table and object comprehensions on the sugar standard library module:

The comprehension is implemented as a macro that is expanded at compile time, 
you can see the expanded code using the expandMacro compiler option:

The comprehensions can be nested and multi-line:

OCaml supports List comprehension through OCaml Batteries .

Array with all the doubles from 1 to 9 inclusive:

Array with the names of the customers based in Rio de Janeiro (from array of hashes):

Filtering numbers divisible by 3:

which is short-hand notation of:

Python uses the following syntax to express list comprehensions over finite lists:

A generator expression may be used in Python versions >= 2.4 which gives lazy evaluation over its input, and can be used with generators to iterate over 'infinite' input such as the count generator function which returns successive integers:

(Subsequent use of the generator expression will determine when to stop generating values).

An example with multiple generators:

Using the for-comprehension:

List comprehensions are supported in Scheme through the use of the SRFI -42 library.

An example of a list comprehension using multiple generators: