In computer programming , homoiconicity (from the Greek words homo- meaning "the same" and icon meaning "representation") is a property of some programming languages . A language is homoiconic if a program written in it can be manipulated as data using the language. The program's internal representation can thus be inferred just by reading the program itself.  This property is often summarized by saying that the language treats code as data .

In a homoiconic language, the primary representation of programs is also a data structure in a primitive type of the language itself. This makes metaprogramming easier than in a language without this property: reflection in the language (examining the program's entities at runtime ) depends on a single, homogeneous structure, and it does not have to handle several different structures that would appear in a complex syntax. Homoiconic languages typically include full support of syntactic macros , allowing the programmer to express transformations of programs in a concise way.

A commonly cited example is Lisp , which was created to allow for easy list manipulations and where the structure is given by S-expressions that take the form of nested lists, and can be manipulated by other Lisp code. Other examples are the programming languages Clojure (a contemporary dialect of Lisp), Rebol (also its successor Red ), Refal , Prolog , and possibly Julia (see the section “Implementation methods” for more details).

The term first appeared in connection with the TRAC programming language , developed by Calvin Mooers :

One of the main design goals was that the input script of TRAC (what is typed in by the user) should be identical to the text which guides the internal action of the TRAC processor. In other words, TRAC procedures should be stored in memory as a string of characters exactly as the user typed them at the keyboard. If the TRAC procedures themselves evolve new procedures, these new procedures should also be stated in the same script. The TRAC processor in its action interprets this script as its program. In other words, the TRAC translator program (the processor) effectively converts the computer into a new computer with a new program language -- the TRAC language. At any time, it should be possible to display program or procedural information in the same form as the TRAC processor will act upon it during its execution. It is desirable that the internal character code representation be identical to, or very similar to, the external code representation. In the present TRAC implementation, the internal character representation is based upon ASCII . Because TRAC procedures and text have the same representation inside and outside the processor, the term homoiconic is applicable, from homo meaning the same, and icon meaning representation.

The last sentence above is annotated with footnote 4, which gives credit for the origin of the term:

Following suggestion of McCullough W. S., based upon terminology due to Peirce, C. S.

The researchers implicated in this quote might be neurophysiologist and cybernetician Warren Sturgis McCulloch (note the difference in the surname from the note) and philosopher, logician and mathematician Charles Sanders Peirce . Pierce indeed used the term "icon" in his Semiotic Theory. According to Peirce, there are three kinds of sign in communication: the icon, the index and the symbol. The icon is the simplest representation: an icon physically resembles that which it denotes.

Alan Kay used and possibly popularized the term "homoiconic" through his use of the term in his 1969 PhD thesis:

A notable group of exceptions to all the previous systems are Interactive LISP [...] and TRAC. Both are functionally oriented (one list, the other string), both talk to the user with one language, and both are "homoiconic" in that their internal and external representations are essentially the same. They both have the ability to dynamically create new functions which may then be elaborated at the users's pleasure. 
Their only great drawback is that programs written in them look like King Burniburiach 's letter to the Sumerians done in Babylonian cuniform! [...]

One advantage of homoiconicity is that extending the language with new concepts typically becomes simpler, as data representing code can be passed between the meta and base layer of the program.  The abstract syntax tree of a function may be composed and manipulated as a data structure in the meta layer, and then evaluated . It can be much easier to understand how to manipulate the code since it can be more easily understood as simple data (since the format of the language itself is as a data format).

A typical demonstration of homoiconicity is the meta-circular evaluator .

All Von Neumann architecture systems, which includes the vast majority of general purpose computers today, can implicitly be described as homoiconic due to the way that raw machine code executes in memory, the data type being bytes in memory.  However, this feature can also be abstracted to the programming language level.

Languages such as Lisp and its dialects, such as Scheme , Clojure , and Racket employ S-expressions to achieve homoiconicity, and are considered the "Purest" forms of homoiconicity, as these languages use the same representation for both data and code.

Other languages provide data structures for easily and efficiently manipulating code. Notable examples of this weaker form of homoiconicity include Julia , Nim , and Elixir .

Languages often considered to be homoiconic include:

Lisp uses S-expressions as an external representation for data and code. S-expressions can be read with the primitive Lisp function READ . READ returns Lisp data: lists, symbols , numbers, strings. The primitive Lisp function EVAL uses Lisp code represented as Lisp data, computes side-effects and returns a result. The result will be printed by the primitive function PRINT , which creates an external S-expression from Lisp data.

Lisp data, a list using different data types: (sub)lists, symbols, strings and integer numbers.

Lisp code. The example uses lists, symbols and numbers.

Create above expression with the primitive Lisp function LIST and set the variable EXPRESSION to the result

Change the COS term to SIN

Evaluate the expression

Print the expression to a string

Read the expression from a string

On line 4 we create a new clause. The operator :- separates the head and the body of a clause. With assert/1 * we add it to the existing clauses (add it to the "database"), so we can call it later. In other languages we would call it "creating a function during runtime". We can also remove clauses from the database with abolish/1 , or retract/1 .

* The number after the clause's name is the number of arguments it can take. It is also called arity .

We can also query the database to get the body of a clause:

call is analogous to Lisp's eval function.

The concept of treating code as data and the manipulation and evaluation thereof can be demonstrated very neatly in Rebol . (Rebol, unlike Lisp, does not require parentheses to separate expressions).

The following is an example of code in Rebol (Note that >> represents the interpreter prompt; spaces between some elements have been added for readability):

( repeat is in fact a built-in function in Rebol and is not a language construct or keyword).

By enclosing the code in square brackets, the interpreter does not evaluate it, but merely treats it as a block containing words:

This block has the type block! and can furthermore be assigned as the value of a word by using what appears to be a syntax for assignment, but is actually understood by the interpreter as a special type ( set-word! ) and takes the form of a word followed by a colon:

The block can still be interpreted by using the do function provided in Rebol (similar to eval in Lisp ).

It is possible to interrogate the elements of the block and change their values, thus altering the behavior of the code if it were to be evaluated: