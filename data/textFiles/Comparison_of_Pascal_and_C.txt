The computer programming languages C and Pascal have similar times of origin, influences, and purposes. Both were used to design (and compile) their own compilers early in their lifetimes. The original Pascal definition appeared in 1969 and a first compiler in 1970. The first version of C appeared in 1972.

Both are descendants of the ALGOL language series. ALGOL introduced programming language support for structured programming , where programs are constructed of single entry and single exit constructs such as if , while , for and case . Pascal stems directly from ALGOL W , while it shared some new ideas with ALGOL 68 . The C language is more indirectly related to ALGOL, originally through B , BCPL , and CPL , and later through ALGOL 68 (for example in case of struct and union ) and also Pascal (for example in case of enumerations, const , typedef and Booleans). Some Pascal dialects also incorporated traits from C.

The languages documented here are the Pascal of Niklaus Wirth , as standardized as ISO 7185 in 1982, and the C of Brian Kernighan and Dennis Ritchie , as standardized in 1989. The reason is that these versions both represent the mature version of the language, and also because they are comparatively close in time. ANSI C and C99 (the later C standards) features, and features of later implementations of Pascal ( Turbo Pascal , Free Pascal ) are not included in the comparison, despite the improvements in robustness and functionality that they conferred.

Syntactically , Pascal is much more ALGOL-like than C . English keywords are retained where C uses punctuation symbols – Pascal has and , or , and mod where C uses && , || , and % for example. However, C is more ALGOL-like than Pascal regarding (simple) declarations, retaining the type-name variable-name syntax. For example, C can accept declarations at the start of any block, not just the outer block of a function.

Another, more subtle, difference is the role of the semicolon . In Pascal, semicolons separate individual statements within a compound statement; instead in C, they terminate the statement. In C, they are also syntactically part of the statement (transforming an expression into a statement). This difference manifests mainly in two situations:

A superfluous semicolon can be put on the last line before end , thereby formally inserting an empty statement .

In traditional C, there are only /* block comments */ . This is only supported by certain Pascal dialects like MIDletPascal.

In traditional Pascal, there are { block comments } and (* block comments *) .
Modern Pascal, like Object Pascal (Delphi, FPC), as well as modern C implementations allow C++ style comments // line comments

C and Pascal differ in their interpretation of upper and lower case. C is case sensitive while Pascal is not, thus MyLabel and mylabel are distinct names in C but identical in Pascal. In both languages, identifiers consist of letters and digits, with the rule that the first character may not be a digit. In C, the underscore counts as a letter, so even _abc is a valid name. Names with a leading underscore are often used to differentiate special system identifiers in C.

Both C and Pascal use keywords (words reserved for use by the language). Examples are if , while , const , for and goto , which are keywords that happen to be common to both languages. In C, the basic built-in type names are also keywords (e.g., int , char ) or combinations of keywords (e.g., unsigned char ), while in Pascal the built-in type names are predefined normal identifiers.

In Pascal, subroutine definitions start with keywords procedure (no value returned) or function (a value is returned) and type definitions with type . In C, all subroutines have function definitions (procedures being void function s) and type definitions use the keyword typedef . Both languages use a mix of keywords and punctuation for definitions of complex types; for instance, arrays are defined by the keyword array in Pascal and by punctuation in C, while enumerations are defined by the keyword enum in C but by punctuation in Pascal.

In Pascal subroutines, begin and end delimit a block of statements preceded by local declarations, while C functions use "{" and "}" to delimit a block of statements optionally preceded by declarations : C (before C99) strictly defines that any declarations must occur before the statements within a particular block but allows blocks to appear within blocks, which is a way to go around this. By its syntax of a subroutine's body, Pascal enforces that declarations occur before statements. Pascal also allows definitions of types and functions – not only variable declarations –  to be encapsulated by function definitions to any level of depth.

The grammars of both languages are of a similar size. From an implementation perspective the main difference between the two languages is that to parse C it is necessary to have access to a symbol table for types, while in Pascal there is only one such construct, assignment. For instance, the C fragment X * Y; could be a declaration of Y to be an object whose type is pointer to X , or a statement-expression that multiplies X and Y . In contrast, the corresponding Pascal fragments var Y : ^X; and Z := X * Y; are inherently unambiguous; correct parsing does not require a symbol table.

Pascal requires all variable and function declarations to specify their type explicitly. In traditional C, a type name may be omitted in most contexts and the default type int (which corresponds to integer in Pascal) is then implicitly assumed (however, such defaults are considered bad practice in C and are often flagged by warnings).

C accommodates different sizes and signed and unsigned modes for integers by using modifiers such as long , short , signed , unsigned , etc. The exact meaning of the resulting integer type is machine-dependent, what can be guaranteed is that long int is no shorter than int and int is no shorter than short int . However, in C standard, there are at least minimal sizes of types are specified which guarantees char to be a single byte and int to be at least two bytes.

In Pascal, a similar end is performed by declaring a subrange of integer (a compiler may then choose to allocate a smaller amount of storage for the declared variable):

This subrange feature is not supported by C.

A major, if subtle, difference between C and Pascal is how they promote integer operations. In Pascal, the result of an operation is defined for all integer/subrange types, even if intermediate results do not fit into an integer. The result is undefined only if it does not fit into the integer/subrange on the left hand side of the assignment. This may imply an artificial restriction on the range of integer types, or may require slow execution to handle the intermediate results: However, the compiler may take advantage of restricted subranges to produce more efficient code.

In C, operands must first be promoted to the size of the required result: intermediate results are undefined if they do not fit into the range of the promoted operands. If range of the required result is greater than the range of operands, this normally produces slow inefficient code, even from a good optimising compiler. However, a C compiler is never required or expected to handle out of range intermediate results: it is the programmers responsibility to ensure that all intermediate results fit into the operand range.

Pre-Standard implementations of C as well as Small-C et al. allowed integer and pointer types to be relatively freely intermixed.

In C the character type is char which is a kind of integer that is no longer than short int , . Expressions such as 'x'+1 are therefore perfectly legal, as are declarations such as int i='i'; and char c=74; .

This integer nature of char (one byte) is clearly illustrated by declarations such as

Whether the char type should be regarded as signed or unsigned by default is up to the implementation.

In Pascal, characters and integers are distinct types. The inbuilt compiler functions ord() and chr() can be used to typecast single characters to the corresponding integer value of the character set in use, and vice versa. e.g. on systems using the ASCII character set ord('1') = 49 and chr(9) is a TAB character.

In Pascal, boolean is an enumerated type. The possible values of boolean are false and true , with ordinal value of false = 0 and true = 1. For conversion to integer , ord is used:

There is no standard function for integer to boolean , however, the conversion is simple in practice:

C has no Boolean type. C uses binary valued relational operators (<, >, ==, !=, <=, >=) which may be regarded as Boolean in the sense that they always give results that are either zero or one. As all tests (&&, ||, ?:, if , while , etc.) are performed by zero-checks, false is represented by zero, while true is represented by any other value. This is visible in the bool numeric datatype defined in stdbool.h .

C allows using bitwise operators to perform Boolean operations. Care must be taken because the semantics are different when operands make use of more than one bit to represent a value.

Pascal has another more abstract, high-level method of dealing with bitwise data, sets . Sets allow the programmer to set, clear, intersect, and unite bitwise data values, rather than using direct bitwise operators (which are available in modern Pascal as well). Example;

Pascal:

C:

Although bit operations on integers and operations on sets can be considered similar if the sets are implemented using bits, there is no direct parallel between their uses unless a non-standard conversion between integers and sets is possible.

During expression evaluation, and in both languages , a Boolean value may be internally stored as a single bit, a single byte, a full machine word, a position in the generated code, or as a condition code in a status register, depending on machine, compiler, and situation; these factors are usually more important than the language compiled.

C has a less strict model of floating point types than Pascal. In C, integers may be implicitly converted to floating point numbers, and vice versa (though possible precision loss may be flagged by warnings). In Pascal, integers may be implicitly converted to real , but conversion of real to integer (where information may be lost) must be done explicitly via the functions trunc() and round() , which truncate or round off the fraction, respectively.

Both C and Pascal include enumeration types. A Pascal example:

A C example:

The behavior of the types in the two languages however is very different. In Pascal enumerations are ordinal and parsed using ord() , succ() and pred() functions and are distinct from the array structure. In C, enumerations are in fact implemented as arrays and red becomes just a synonym for 0, green for 1, blue for 2, and nothing prevents a value outside this range to be assigned to the variable a . Furthermore, operations like a = a + 1; are strictly forbidden in Pascal; instead you would use a := succ(a); . In C, enums can be freely converted to and from ints, but in Pascal, the function ord() must be used to convert from enumerated types to integers, in opposite conversion must be used typecast operation like a := color(1) for green value return.

Both C and Pascal allow arrays of other complex types, including other arrays. However, there the similarity between the languages ends. C arrays are simply defined by a base type and the number of elements:

and are always indexed from 0 up to SIZE−1 (i.e. modulo SIZE).

In Pascal, the range of indices is often specified by a subrange (as introduced under simple types above). The ten elements of

would be indexed by 0..9 (just as in C in this case). Array indices can be any ordinal data type , however, not just ranges:

Strings consisting of n (>1) characters are defined as packed arrays with range 1..n.

In C expressions, an identifier representing an array is treated as a constant pointer to the first element of the array, thus, given the declarations int a[10] and int *p; the assignment p = a is valid and causes p and a to point to the same array. As the identifier a represents a constant address, a = p is not valid however.

While arrays in C are fixed, pointers to them are interchangeable. This flexibility allows C to manipulate any length array using the same code. It also leaves the programmer with the responsibility not to write outside the allocated array, as no checks are built in into the language.

In Pascal, arrays are a distinct type from pointers. This makes bounds checking for arrays possible from a compiler perspective. Practically all Pascal compilers support range checking as a compile option .
The ability to both have arrays that change length at runtime, and be able to check them under language control, is often termed "dynamic arrays". In Pascal the number of elements in each array type is determined at compile-time and cannot be changed during the execution of the program. Hence, it is not possible to define an array whose length depends in any way on program data. (Note : since 1986 and Turbo Pascal 3, which was the industry standard, GetMem() allows dynamic arrays in everyday Pascal, if not in the ISO standard)

C has the ability to initialize arrays of arbitrary length. The sizeof operator can be used to obtain the size of a statically initialized array in C code.  For instance in the following code, the terminating index for the loop automatically adjusts should the list of strings be changed.

Likewise modern Pascal, e.g. Delphi and Free Pascal, has a similar ability.  Initialized arrays can be implemented as:

Original Pascal has neither array initialization (outside of the case of strings) nor a means of determining arbitrary array sizes at compile time.  One way of implementing the above example in original Pascal, but without the automatic size adjustment, is:

In both languages, a string is a primitive array of characters.

In Pascal a string literal of length n is compatible with the type packed array [1..n] of char . In C a string generally has the type char[n] .

Pascal has no support for variable-length arrays, and so any set of routines to perform string operations is dependent on a particular string size. The now standardized Pascal "conformant array parameter" extension solves this to a great extent, and many or even most implementations of Pascal have support for strings native to the language.

C string literals are null-terminated ; that is to say, a trailing null character as an end-of-string sentinel :

Null-termination must be manually maintained for string variables stored in arrays (this is often partly handled by library routines).

C lacks built-in string or array assignment, so the string is not being transferred to p, but rather p is being made to point to the constant string in memory.

In Pascal, unlike C, the string's first character element is at index 1 and not 0 (leading it to be length-prefixed ). This is because Pascal stores the length of the string at the 0th element of the character array. If this difference is not well understood it can lead to errors when porting or trying to interface object code generated by both languages.

FreeBSD developer Poul-Henning Kamp , writing in ACM Queue , would later refer to the victory of null-terminated strings over length-prefixed strings as "the most expensive one-byte mistake" ever.

Both C and Pascal can declare " record " types. In C, they are termed "structures".

In Pascal, we can use the sentence " with name_of_record do" in order to use directly the fields of that record, like local variables, instead of write name_of_record . name_of_field . Here there is an example:

There is no equivalent feature to with in C.

In C, the exact bit length of a field can be specified:

How much storage is used depends on traits (e.g., word-alignment) of the target system.

This feature is available in Pascal by using the subrange construct (3 bits gives a range from 0 to 7) in association with the keyword packed :

Both C and Pascal support records which can include different fields overlapping each other:

Both language processors are free to allocate only as much space for these records as needed to contain the largest type in the union/record.
In Pascal, such constructs are called variant records , not to be mistaken with the Variant datatype defined in Free Pascal.

The biggest difference between C and Pascal is that Pascal supports the explicit use of a "tagfield" for the language processor to determine if the valid component of the variant record is being accessed:

In this case, the tag field q must be set to the right state to access the proper parts of the record.

In C, pointers can be made to point at most program entities, including objects or functions:

In C, since arrays and pointers have a close equivalence, the following are the same:

Thus, pointers are often used in C as just another method to access arrays.

To create dynamic data, the library functions malloc() and free() are used to obtain and release dynamic blocks of data. Thus, dynamic memory allocation is not built into the language processor. This is especially valuable when C is being used in operating system kernels or embedded targets as these things are very platform (not just architecture) specific and would require changing the C compiler for each platform (or operating system) that it would be used on.

Pascal has the same kind of pointers as C, through the ^ referencing operator instead of the * of C. Each pointer is bound to a single dynamic data item, and can only be moved by assignment:

Pointers in Pascal are type safe; i.e. a pointer to one data type can only be assigned to a pointer of the same data type. Also pointers can never be assigned to non-pointer variables. Pointer arithmetic (a common source of programming errors in C, especially when combined with endianness issues and platform-independent type sizes) is not permitted in Pascal.
All of these restrictions reduce the possibility of pointer-related errors in Pascal compared to C, but do not prevent invalid pointer references in Pascal altogether. For example, a runtime error will occur if a pointer is referenced before it has been initialized or after it has been disposed of.

The languages differ significantly when it comes to expression evaluation, but all-in-all they are comparable.

Pascal

C

Most operators serve several purposes in Pascal, for instance, the minus sign may be used for negation, subtraction, or set difference (depending on both type and syntactical context), the >= operator may be used to compare numbers, strings, or sets, and so on. C uses dedicated operator symbols to a greater extent.

The two languages use different operators for assignment. Pascal, like ALGOL , uses the mathematical equality operator = for the equality test and the symbol := for assignment, whereas C, like B , uses the mathematical equality operator for assignment. In C (and B) the == symbol of FORTRAN was chosen for the equality test.

It is a common mistake in C, due either to inexperience or to a simple typing error, to accidentally put assignment expressions in conditional statements such as if ( a = 10 ) { ... } . The code in braces will always execute because the assignment expression a = 10 has the value 10 which is non-zero and therefore considered "true" in C; this is in part because C (and ALGOL) allow multiple assignment in the form a = b = c = 10; which is not supported by Pascal. Also note that a now has the value 10 , which may affect the following code. Recent C compilers try to detect these cases and warn the user, asking for a less ambiguous syntax like if (( a = 10 ) != 0 ) { ... } .

This kind of mistake cannot happen in Pascal, as assignments are not expressions and do not have a value: using the wrong operator will cause an unambiguous compilation error, and it's also less likely that anyone would mistake the := symbol for an equality test.

It is notable that ALGOL's conditional expression in the form z := if a > b then a else b ; has an equivalent in C (the ternary operator from CPL ) but not in Pascal, which will use if a > b then z := a ; else z := b ; .

When Niklaus Wirth designed Pascal, the desire was to limit the number of levels of precedence (fewer parse routines, after all). So the OR and exclusive OR operators are treated just like an Addop and processed at the level of a math expression. Similarly, the AND is treated like a Mulop and processed with Term. The precedence levels are

Notice that there is only ONE set of syntax rules, applying to both kinds of operators. According to this grammar, then, expressions like

are perfectly legal. And, in fact, they are, as far as the parser is concerned. Pascal does not allow the mixing of arithmetic and Boolean variables, and things like this are caught at the semantic level, when it comes time to generate code for them, rather than at the syntax level.

The authors of C took a diametrically opposite approach: they treat the operators as different, and in fact, in C there are no fewer than 15 levels. That's because C also has the operators '=', '+=' and its kin, '<<', '>>', '++', '--', etc. Although in C the arithmetic and Boolean operators are treated separately, the variables are not: a Boolean test can be made on any integer value.

In Pascal a boolean expression that relies on a particular evaluation ordering (possibly via side-effects in function calls) is, more or less, regarded as an error. The Pascal compiler has the freedom to use whatever ordering it may prefer and must always evaluate the whole expression even if the result can be determined by partial evaluation. (Note: since Turbo Pascal 3 (1986) the short-circuit Boolean evaluation is available in everyday Pascal, if not in the ISO standard).

In C, dependence on boolean evaluation order is perfectly legal, and often systematically employed using the && and || operators together with operators such as ++ , += , the comma operator, etc. The && and || operators thereby function as combinations of logical operators and conditional statements .

Short circuit expression evaluation has been commonly considered an advantage for C because of the "evaluation problem":

This seemingly straightforward search is problematic in Pascal because the array access a[i] would be invalid for i equal to 11.
There is more than one way to avoid this problem. The following example introduces a Boolean variable which indicates whether or not the target character has been found:

Alternatively, the test for end of array can be separated from the array access and a goto statement can break out of the search if the target is found:

Statements for building control structures are roughly analogous and relatively similar (at least the first three).

Pascal, in its original form, did not have an equivalent to default , but an equivalent else clause is a common extension. Pascal programmers otherwise had to guard case-statements with an expression such as: if expr not in [A..B] then default-case .

C has the so-called early-out statements break and continue , and some Pascals have them as well.

Both C and Pascal have a goto statement. However, since Pascal has nested procedures/functions, jumps can be done from an inner procedure or function to the containing one; this was commonly used to implement error recovery. C has this ability via the ANSI C setjmp and longjmp . This is equivalent, but arguably less safe, since it stores program specific information like jump addresses and stack frames in a programmer accessible structure.

Pascal routines that return a value are called functions; routines that do not return a value are called procedures. All routines in C are called functions; C functions that do not return a value are declared with a return type of void .

Pascal procedures are considered equivalent to C "void" functions, and Pascal functions are equivalent to C functions that return a value.

The following two declarations in C:

are equivalent to the following declarations in Pascal:

Pascal has two different types of parameters: pass-by-value, and pass-by-reference (VAR). In both cases the variable name is used when calling (no need of address operator).

In C all parameters are passed by value but pass-by-reference can be simulated using pointers. The following segment is similar to the Pascal segment above:

One of the most important difference between C and Pascal is the way they handle the parameters on stack during a subroutine call :
This is called the calling convention :
PASCAL-style parameters are pushed on the stack in left-to-right order.
The STDCALL calling convention of C pushes the parameters on the stack in right-to-left order.

Pascal-style procedure call is made with :

The advantage of PASCAL call over STDCALL is that the code is slightly smaller, though the size impact is only visible in large programs, and that recursion works faster.

Variadic functions are almost impossible to get right with PASCAL and STDCALL methods, because only the caller really knows how many arguments were passed in order to clean them up.

C allows for functions to accept a variable number of parameters, known as variadic functions , using a clumsy mechanism of va_list ap; , va_start(ap, count); , va_arg(ap, type ); with limited type availability (example : nothing for bool )

The function f() uses a special set of functions ( varargs ) that allow it to access each of the parameters in turn.

Pascal and C also have some variadic I/O functions, for instance WriteLn() and printf() .

Modern Pascals enable a variable number of parameters for functions :

They also enable to interface with varargs C functions :

Pascal allows procedures and functions to be nested . This is convenient to allow variables that are local to a group of procedures, but not global. C lacks this feature and the localization of variables or functions can be done only for a compiling module wherein the variables or functions would have been declared static .

C and Pascal allow functions to be indirectly invoked through a function pointer . In the following example, the statement (*cmpar)(s1, s2) is equivalent to strcmp(s1, s2) :

In Pascal functions and procedures can be passed as parameters to functions or procedures:

Early C had neither constant declarations nor type declarations, and the C language was originally defined as needing a " preprocessor "; a separate program, and pass, that handled constant, include and macro definitions, to keep memory usage down. Later, with ANSI C, it obtained constant and type definitions features and the preprocessor also became part of the language, leading to the syntax we see today.

Pascal constant and type defines are built in and don't need a preprocessor.
There were programmers using a preprocessor also with Pascal (sometimes the same one used with C), certainly not as common as with C. Although often pointed out as a "lack" in Pascal, technically C does not have program modularity nor macros built in either. It has a simple low level separate compilation facility, however (traditionally using the same generic linker used for assembly language), Pascal does not.

In C, the programmer may inspect the byte-level representation of any object by pointing a char pointer to it:

It may be possible to do something similar in Pascal using an undiscriminated variant record:

Although casting is possible on most Pascal compilers and interpreters, even in the code above a2c.a and a2c.b are not required by any Pascal standardizations to share the same address space. Niklaus Wirth, the designer of Pascal, has written about the problematic nature of attempting type escapes using this approach:

"Most implementors of Pascal decided that this checking would be too expensive, enlarging code and deteriorating program efficiency. As a consequence, the variant record became a favourite feature to breach the type system by all programmers in love with tricks, which usually turn into pitfalls and calamities".

Several languages now specifically exclude such type escapes, for example Java, C# and Wirth's own Oberon .

In C files do not exist as a built-in type (they are defined in a system header) and all I/O takes place via library calls. Pascal has file handling built into the language.

The typical statements used to perform I/O in each language are:

The main difference is that C uses a "format string" that is interpreted to find the arguments to the printf function and convert them, whereas Pascal performs that under the control of the language processor. The Pascal method is arguably faster, because no interpretation takes place, but the C method is highly extensible.

Some popular Pascal implementations have incorporated virtually all C constructs into Pascal. Examples include type casts, being able to obtain the address of any variable, local or global, and different types of integers with special promotion properties.

However, the incorporation of C's lenient attitude towards types and type conversions can result in a Pascal that loses some or all of its type security. For example, Java and C# were created in part to address some of the perceived type security issues of C, and have "managed" pointers that cannot be used to create invalid references. In its original form (as described by Niklaus Wirth ), Pascal qualifies as a managed pointer language, some 30 years before either Java or C#. However, a Pascal amalgamated with C would lose that protection by definition. In general, the lower dependence on pointers for basic tasks makes it safer than C in practice.

The Extended Pascal standard extends Pascal to support many things C supports, which the original standard Pascal did not, in a type safer manner. For example, schema types support (besides other uses) variable-length arrays while keeping the type-safety of mandatory carrying the array dimension with the array, allowing automatic run-time checks for out-of-range indices also for dynamically sized arrays.