Answer set programming ( ASP ) is a form of declarative programming oriented towards difficult (primarily NP-hard ) search problems .  It is based on the stable model (answer set) semantics of logic programming .  In ASP, search problems are reduced to computing stable models, and answer set solvers —programs for generating stable models—are used to perform search.  The computational process employed in the design of many answer set solvers is an enhancement of the DPLL algorithm and, in principle, it always terminates (unlike Prolog query evaluation, which may lead to an infinite loop ).

In a more general sense, ASP includes all applications of answer sets to knowledge representation and reasoning and the use of Prolog-style query evaluation for solving problems arising in these applications.

An early example of answer set programming was the planning method proposed in 1997 by Dimopoulos, Nebel and Köhler. Their approach is based on the relationship between plans and stable models. In 1998 Soininen and Niemelä applied what is now known as answer set programming to the problem of product configuration . In 1999, the term "answer set programming" appeared for the first time in a book The Logic Programming Paradigm as the title of a collection of two papers. The first of these papers identified the use of answer set solvers for search as a new programming paradigm . That same year Niemelä also proposed "logic programs with stable model semantics" as a new paradigm.

Lparse is the name of the program that was originally created as a grounding tool (front-end) for the answer set solver smodels . The language that Lparse accepts is now commonly called AnsProlog, short for Answer Set Programming in Logic . It is now used in the same way in many other answer set solvers, including assat , clasp , cmodels , gNt , nomore++ and pbmodels . ( dlv is an exception; the syntax of ASP programs written for dlv is somewhat different.)

An AnsProlog program consists of rules of the form

The symbol :- ("if") is dropped if <body> is empty; such rules are called facts .  The simplest kind of Lparse rules are rules with constraints .

One other useful construct included in this language is choice .  For instance, the choice rule

says: choose arbitrarily which of the atoms p , q , r {\displaystyle p,q,r} to include in the stable model.  The Lparse program that contains this choice rule and no other rules has 8 stable models—arbitrary subsets of { p , q , r } {\displaystyle \{p,q,r\}} .  The definition of a stable model was generalized to programs with choice rules. Choice rules can be treated also as abbreviations for propositional formulas under the stable model semantics . For instance, the choice rule above can be viewed as shorthand for the conjunction of three " excluded middle " formulas:

The language of Lparse allows us also to write "constrained" choice rules, such as

This rule says: choose at least 1 of the atoms p , q , r {\displaystyle p,q,r} , but not more than 2.  The meaning of this rule under the stable model semantics is represented by the propositional formula

Cardinality bounds can be used in the body of a rule as well, for instance:

Adding this constraint to an Lparse program eliminates the stable models that contain at least 2 of the atoms p , q , r {\displaystyle p,q,r} .  The meaning of this rule can be represented by the propositional formula

Variables (capitalized, as in Prolog ) are used in Lparse to abbreviate collections of rules that follow the same pattern, and also to abbreviate collections of atoms within the same rule.  For instance, the Lparse program

has the same meaning as

The program

is shorthand for

A range is of the form:

where start and end are constant-valued arithmetic expressions. A range is a notational shortcut that is mainly used to define numerical domains in a compatible way. For example, the fact

is a shortcut for

Ranges can also be used in rule bodies with the same semantics.

A conditional literal is of the form:

If the extension of q is {q(a1), q(a2), ..., q(aN)} , the above condition is semantically equivalent to writing {p(a1), p(a2), ..., p(aN)} in the place of the condition. For example,

is a shorthand for

To find a stable model of the Lparse program stored in file ${filename} we use the command

Option 0 instructs smodels to find all stable models of the program.  For instance, if file test contains the rules

then the command produces the output

An n {\displaystyle n} - coloring of a graph G = ⟨ V , E ⟩ {\displaystyle G=\left\langle V,E\right\rangle } is a function c o l o r : V → { 1 , … , n } {\displaystyle \mathrm {color} :V\to \{1,\dots ,n\}} such that c o l o r ( x ) ≠ c o l o r ( y ) {\displaystyle \mathrm {color} (x)\neq \mathrm {color} (y)} for every pair of adjacent vertices ( x , y ) ∈ E {\displaystyle (x,y)\in E} . We would like to use ASP to find an n {\displaystyle n} -coloring of a given graph (or determine that it does not exist).

This can be accomplished using the following Lparse program:

Line 1 defines the numbers 1 , … , n {\displaystyle 1,\dots ,n} to be colors.  According to the choice rule in Line 2, a unique color i {\displaystyle i} should be assigned  to each vertex x {\displaystyle x} .  The constraint in Line 3 prohibits assigning the same color to vertices x {\displaystyle x} and y {\displaystyle y} if there is an edge connecting them.

If we combine this file with a definition of G {\displaystyle G} , such as

and run smodels on it, with the numeric value of n {\displaystyle n} specified on the command line, then the atoms of the form c o l o r ( … , … ) {\displaystyle \mathrm {color} (\dots ,\dots )} in the output of smodels will represent an n {\displaystyle n} -coloring of G {\displaystyle G} .

The program in this example illustrates the "generate-and-test" organization that is often found in simple ASP programs.  The choice rule describes a set of "potential solutions"—a simple superset of the set of solutions to the given search problem.  It is followed by a constraint, which eliminates all potential solutions that are not acceptable.  However, the search process employed by smodels and other answer set solvers is not based on trial and error .

A clique in a graph is a set of pairwise adjacent vertices.  The following Lparse program finds a clique of size ≥ n {\displaystyle \geq n} in a given directed graph, or determines that it does not exist:

This is another example of the generate-and-test organization.  The choice rule in Line 1 "generates" all sets consisting of ≥ n {\displaystyle \geq n} vertices.  The constraint in Line 2 "weeds out" the sets that are not cliques.

A Hamiltonian cycle in a directed graph is a cycle that passes through each vertex of the graph exactly once.  The following Lparse program can be used to find a Hamiltonian cycle in a given directed graph if it exists; we assume that 0 is one of the vertices.

The choice rule in Line 1 "generates" all subsets of the set of edges.  The three constraints "weed out" the subsets that are not Hamiltonian cycles.  The last of them uses the auxiliary predicate r ( x ) {\displaystyle r(x)} (" x {\displaystyle x} is reachable from 0") to prohibit the  vertices that do not satisfy this condition.  This predicate is defined recursively in Lines 6 and 7.

This program is an example of the more general "generate, define and test" organization: it includes the definition of an auxiliary predicate that helps us eliminate all "bad" potential solutions.

In natural language processing , dependency-based parsing can be formulated as an ASP problem. The following code parses the Latin sentence "Puella pulchra in villa linguam latinam discit", "the pretty girl is learning Latin in the villa".
The syntax tree is expressed by the arc predicates which represent the dependencies between the words of the sentence.
The computed structure is a linearly ordered rooted tree.

The ASP standardization working group produced a standard language specification, called ASP-Core-2, towards which recent ASP systems are converging. ASP-Core-2 is the reference language for the Answer Set Programming Competition, in which ASP solvers are periodically benchmarked over a number of reference problems.

Early systems, such as smodels, used backtracking to find solutions.  As the theory and practice of Boolean SAT solvers evolved, a number of ASP solvers were built on top of SAT solvers, including ASSAT and Cmodels. These converted ASP formula into SAT propositions, applied the SAT solver, and then converted the solutions back to ASP form. More recent systems, such as Clasp, use a hybrid approach, using conflict-driven algorithms inspired by SAT, without fully converting into a Boolean-logic form.  These approaches allow for significant improvements of performance, often by an order of magnitude, over earlier backtracking algorithms.

The Potassco project acts as an umbrella for many of the systems below, including clasp , grounding systems ( gringo ), incremental systems ( iclingo ), constraint solvers ( clingcon ), action language to ASP compilers ( coala ),  distributed Message Passing Interface implementations ( claspar ), and many others.

Most systems support variables, but only indirectly, by forcing grounding, by using  a grounding system such as Lparse or gringo as a front end. The need for grounding can cause a combinatorial explosion of clauses; thus, systems that perform on-the-fly grounding might have an advantage.

Query-driven implementations of answer set programming, such as the Galliwasp system and s(CASP) avoid grounding altogether by using a combination of resolution and coinduction .