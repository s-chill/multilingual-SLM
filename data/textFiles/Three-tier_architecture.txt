In software engineering , multitier architecture (often referred to as n -tier architecture ) is a client–server architecture in which presentation, application processing and data management functions are physically separated. The most widespread use of multitier architecture is the three-tier architecture .

N -tier application architecture provides a model by which developers can create flexible and reusable applications. By segregating an application into tiers, developers acquire the option of modifying or adding a specific tier, instead of reworking the entire application. N-tier architecture is a good fit for small and simple applications because of its simplicity and low-cost. Also, it can be a good starting point when architectural requirements are not clear yet. A three-tier architecture is typically composed of a presentation tier, a logic tier, and a data tier.

While the concepts of layer and tier are often used interchangeably, one fairly common point of view is that there is indeed a difference. This view holds that a layer is a logical structuring mechanism for the conceptual elements that make up the software solution, while a tier is a physical structuring mechanism for the hardware elements that make up the system infrastructure. For example, a three-layer solution could easily be deployed on a single tier, such in the case of an extreme database-centric architecture called RDBMS-only architecture or in a personal workstation.

The "Layers" architectural pattern has been described in various publications.

In a logical multilayer architecture for an information system with an object-oriented design , the following four are the most common:

The book Domain Driven Design describes some common uses for the above four layers, although its primary focus is the domain layer .

If the application architecture has no explicit distinction between the business layer and the presentation layer (i.e., the presentation layer is considered part of the business layer), then a traditional client-server (two-tier) model has been implemented.

The more usual convention is that the application layer (or service layer) is considered a sublayer of the business layer, typically encapsulating the API definition surfacing the supported business functionality. The application/business layers can, in fact, be further subdivided to emphasize additional sublayers of distinct responsibility. For example, if the model–view–presenter pattern is used, the presenter sublayer might be used as an additional layer between the user interface layer and the business/application layer (as represented by the model sublayer).

Some also identify a separate layer called the business infrastructure layer (BI), located between the business layer(s) and the infrastructure layer(s). It is also sometimes called the "low-level business layer" or the "business services layer".  This layer is very general and can be used in several application tiers (e.g. a CurrencyConverter).

The infrastructure layer can be partitioned into different levels (high-level or low-level technical services). Developers often focus on the persistence (data access) capabilities of the infrastructure layer and therefore only talk about the persistence layer or the data access layer (instead of an infrastructure layer or technical services layer). In other words, the other kind of technical services is not always explicitly thought of as part of any particular layer. . The Data Access layer normally contains an object known as the Data Access Object (DAO) .

A layer is on top of another, because it depends on it.  Every layer can exist without the layers above it, and requires the layers below it to function. Another common view is that layers do not always strictly depend on only the adjacent layer below. For example, in a relaxed layered system (as opposed to a strict layered system) a layer can also depend on all the layers below it. The relaxed layered system has more couplings and subsequently it's more difficult to change. Multi-tier architectures can use a hybrid approach so that some layers are strict while other layers are relaxed.

Three-tier architecture is a client-server software architecture pattern in which the user interface (presentation), functional process logic ("business rules"), computer data storage and data access are developed and maintained as independent modules , most often on separate platforms . It was developed by John J. Donovan in Open Environment Corporation (OEC), a tools company he founded in Cambridge, Massachusetts .

Apart from the usual advantages of modular software with well-defined interfaces, the three-tier architecture is intended to allow any of the three tiers to be upgraded or replaced independently in response to changes in requirements or technology . For example, a change of operating system in the presentation tier would only affect the user interface code.

Typically, the user interface runs on a desktop PC or workstation and uses a standard graphical user interface , functional process logic that may consist of one or more separate modules running on a workstation or application server , and an RDBMS on a database server or mainframe that contains the computer data storage logic. The middle tier may be multitiered itself (in which case the overall architecture is called an " n -tier architecture").

In the web development field, three-tier is often used to refer to websites , commonly electronic commerce websites, which are built using three tiers:

Data transfer between tiers is part of the architecture. Protocols involved may include one or more of SNMP , CORBA , Java RMI , .NET Remoting , Windows Communication Foundation , sockets , UDP , web services or other standard or proprietary protocols. Often middleware is used to connect the separate tiers. Separate tiers often (but not necessarily) run on separate physical servers, and each tier may itself run on a cluster .

The end-to-end traceability of data flows through n -tier systems is a challenging task which becomes more important when systems increase in complexity. The Application Response Measurement defines concepts and APIs for measuring performance and correlating transactions between tiers. 
Generally, the term "tiers" is used to describe physical distribution of components of a system on separate servers, computers, or networks (processing nodes). A three-tier architecture then will have three processing nodes. The term "layers" refers to a logical grouping of components which may or may not be physically located on one processing node.