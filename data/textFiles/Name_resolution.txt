In programming languages , name resolution is the resolution of the tokens within program expressions to the intended program components.

Expressions in computer programs reference variables, data types, functions, classes, objects, libraries, packages and other entities by name. In that context, name resolution refers to the association of those not-necessarily-unique names with the intended program entities. The algorithms that determine what those identifiers refer to in specific contexts are part of the language definition.

The complexity of these algorithms is influenced by the sophistication of the language. For example, name resolution in assembly language usually involves only a single simple table lookup , while name resolution in C++ is extremely complicated as it involves:

In programming languages , name resolution can be performed either at compile time or at runtime . The former is called static name resolution , the latter is called dynamic name resolution .

A somewhat common misconception is that dynamic typing implies dynamic name resolution. For example, Erlang is dynamically typed but has static name resolution. However, static typing does imply static name resolution.

Static name resolution catches, at compile time, use of variables that are not in scope; preventing programmer errors. Languages with dynamic scope resolution sacrifice this safety for more flexibility; they can typically set and get variables in the same scope at runtime.

For example, in the Python interactive REPL :

However, relying on dynamic name resolution in code is discouraged by the Python community. The feature also may be removed in a later version of Python.

Examples of languages that use static name resolution include C , C++ , E , Erlang , Haskell , Java , Pascal , Scheme , and Smalltalk . Examples of languages that use dynamic name resolution include some Lisp dialects, Perl , PHP , Python , Rebol , and Tcl .

Masking occurs when the same identifier is used for different entities in overlapping lexical scopes. At the level of variables (rather than names), this is known as variable shadowing . An identifier I' (for variable X') masks an identifier I (for variable X) when two conditions are met

The outer variable X is said to be shadowed by the inner variable X'.

For example, the parameter "foo" shadows the local variable "foo" in this common pattern:

Name masking can cause complications in function overloading , due to overloading not happening across scopes in some languages, notably C++, thus requiring all overloaded functions to be redeclared or explicitly imported into a given namespace.

In programming languages with lexical scoping that do not reflect over variable names, α-conversion (or α-renaming) can be used to make name resolution easy by finding a substitution that makes sure that no variable name masks another name in a containing scope. Alpha-renaming can make static code analysis easier since only the alpha renamer needs to understand the language's scoping rules.

For example, in this code:

within the Point constructor, the instance variables x and y are shadowed by local variables of the same name.  This might be alpha-renamed to:

In the new version, there is no masking, so it is immediately obvious which uses correspond to which declarations.