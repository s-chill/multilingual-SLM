The C and C++ programming languages are closely related but have many significant differences. C++ began as a fork of an early, pre- standardized C, and was designed to be mostly source-and-link compatible with C compilers of the time. Due to this, development tools for the two languages (such as IDEs and compilers ) are often integrated into a single product, with the programmer able to specify C or C++ as their source language.

However, C is not a subset of C++, and nontrivial C programs will not compile as C++ code without modification. Likewise, C++ introduces many features that are not available in C and in practice almost all code written in C++ is not conforming C code. This article, however, focuses on differences that cause conforming C code to be ill-formed C++ code, or to be conforming/well-formed in both languages but to behave differently in C and C++.

Bjarne Stroustrup , the creator of C++, has suggested that the incompatibilities between C and C++ should be reduced as much as possible in order to maximize interoperability between the two languages. Others have argued that since C and C++ are two different languages, compatibility between them is useful but not vital; according to this camp, efforts to reduce incompatibility should not hinder attempts to improve each language in isolation. The official rationale for the 1999 C standard ( C99 ) "endorse[d] the principle of maintaining the largest common subset" between C and C++ "while maintaining a distinction between them and allowing them to evolve separately", and stated that the authors were "content to let C++ be the big and ambitious language."

Several additions of C99 are not supported in the current C++ standard or conflicted with C++ features, such as variable-length arrays , native complex number types and the restrict type qualifier . On the other hand, C99 reduced some other incompatibilities compared with C89 by incorporating C++ features such as // comments and mixed declarations and code.

C++ enforces stricter typing rules (no implicit violations of the static type system ), and initialization requirements (compile-time enforcement that in-scope variables do not have initialization subverted) than C, and so some valid C code is invalid in C++. A rationale for these is provided in Annex C.1 of the ISO C++ standard.

C99 and C11 added several additional features to C that have not been incorporated into standard C++ as of C++20 , such as complex numbers, variable length arrays (complex numbers and variable length arrays are designated as optional extensions in C11), flexible array members , the restrict keyword, array parameter qualifiers, and compound literals .

C++ adds numerous additional keywords to support its new features. This renders C code using those keywords for identifiers invalid in C++. For example:

There are a few syntactic constructs that are valid in both C and C++ but produce different results in the two languages.

Several of the other differences from the previous section can also be exploited to create code that compiles in both languages but behaves differently.  For example, the following function will return different values in C and C++:

This is due to C requiring struct in front of structure tags (and so sizeof(T) refers to the variable), but C++ allowing it to be omitted (and so sizeof(T) refers to the implicit typedef ). Beware that the outcome is different when the extern declaration is placed inside the function: then the presence of an identifier with same name in the function scope inhibits the implicit typedef to take effect for C++, and the outcome for C and C++ would be the same. Observe also that the ambiguity in the example above is due to the use of the parenthesis with the sizeof operator. Using sizeof T would expect T to be an expression and not a type, and thus the example would not compile with C++.

While C and C++ maintain a large degree of source compatibility, the object files their respective compilers produce can have important differences that manifest themselves when intermixing C and C++ code.  Notably:

For these reasons, for C++ code to call a C function foo() , the C++ code must prototype foo() with extern "C" . Likewise, for C code to call a C++ function bar() , the C++ code for bar() must be declared with extern "C" .

A common practice for header files to maintain both C and C++ compatibility is to make its declaration be extern "C" for the scope of the header:

Differences between C and C++ linkage and calling conventions can also have subtle implications for code that uses function pointers . Some compilers will produce non-working code if a function pointer declared extern "C" points to a C++ function that is not declared extern "C" .

For example, the following code:

Using Sun Microsystems ' C++ compiler, this produces the following warning:

This is because my_function() is not declared with C linkage and calling conventions, but is being passed to the C function foo() .