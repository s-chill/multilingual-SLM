The structure of the Perl programming language encompasses both the syntactical rules of the language and the general ways in which programs are organized. Perl's design philosophy is expressed in the commonly cited motto " there's more than one way to do it ". As a multi-paradigm , dynamically typed language, Perl allows a great degree of flexibility in program design. Perl also encourages modularization; this has been attributed to the component-based design structure of its Unix roots , and is responsible for the size of the CPAN archive, a community-maintained repository of more than 100,000 modules.

In Perl, the minimal Hello World program may be written as follows:

This prints the string Hello, World! and a newline , symbolically expressed by an n character whose interpretation is altered by the preceding escape character (a backslash). Since version 5.10, the new 'say' builtin produces the same effect even more simply:

An entire Perl program may also be specified as a command-line parameter to Perl, so the same program can also be executed from the command line (example shown for Unix):

The canonical form of the program is slightly more verbose:

The hash mark character introduces a comment in Perl, which runs up to the end of the line of code and is ignored by the compiler (except on Windows). The comment used here is of a special kind: it’s called the shebang line. This tells Unix-like operating systems to find the Perl interpreter, making it possible to invoke the program without explicitly mentioning perl . (Note that, on Microsoft Windows systems, Perl programs are typically invoked by associating the .pl extension with the Perl interpreter. In order to deal with such circumstances, perl detects the shebang line and parses it for switches. )

The second line in the canonical form includes a semicolon, which is used to separate statements in Perl. With only a single statement in a block or file, a separator is unnecessary, so it can be omitted from the minimal form of the program—or more generally from the final statement in any block or file. The canonical form includes it, because it is common to terminate every statement even when it is unnecessary to do so, as this makes editing easier: code can be added to, or moved away from, the end of a block or file without having to adjust semicolons.

Version 5.10 of Perl introduces a say function that implicitly appends a newline character to its output, making the minimal "Hello World" program even shorter:

Perl has a number of fundamental data types . The most commonly used and discussed are scalars , arrays , hashes , filehandles , and subroutines :

String values (literals) must be enclosed by quotes. Enclosing a string in double quotes allows the values of variables whose names appear in the string to automatically replace the variable name (or be interpolated ) in the string. Enclosing a string in single quotes prevents variable interpolation.

For example, if $name is "Jim" :

To include a double quotation mark in a string, precede it with a backslash or enclose the string in single quotes. To include a single quotation mark, precede it with a backslash or enclose the string in double quotes.

Strings can also be quoted with the q and qq quote-like operators:

Finally, multiline strings can be defined using here documents :

Numbers (numeric constants) do not require quotation. Perl will convert numbers into strings and vice versa depending on the context in which they are used. When strings are converted into numbers, trailing non-numeric parts of the strings are discarded. If no leading part of a string is numeric, the string will be converted to the number 0. In the following example, the strings $n and $m are treated as numbers. This code prints the number '5'. The values of the variables remain the same. Note that in Perl, + is always the numeric addition operator. The string concatenation operator is the period.

Functions are provided for the rounding of fractional values to integer values: int chops off the fractional part, rounding towards zero; POSIX::ceil and POSIX::floor round always up and always down, respectively. The number-to-string conversion of printf "%f" or sprintf "%f" round out even, use bankers' rounding .

Perl also has a boolean context that it uses in evaluating conditional statements. The following values all evaluate as false in Perl:

All other (non-zero evaluating) values evaluate to true. This includes the odd self-describing literal string of "0 but true", which in fact is 0 as a number, but true when used as a boolean. All non-numeric strings also have this property, but this particular string is truncated by Perl without a numeric warning. A less explicit but more conceptually portable version of this string is ' 0E0 ' or ' 0e0 ', which does not rely on characters being evaluated as 0, because '0E0' is literally zero times ten to the power zero. The empty hash {} is also true; in this context {} is not an empty block, because perl -e 'print ref {}' returns HASH .

Evaluated boolean expressions are also scalar values. The documentation does not promise which particular value of true or false is returned. Many boolean operators return 1 for true and the empty-string for false. The defined() function determines whether a variable has any value set. In the above examples, defined($false) is true for every value except undef .

If either 1 or 0 are specifically needed, an explicit conversion can be done using the conditional operator :

An array value (or list) is specified by listing its elements, separated by commas, enclosed by parentheses (at least where required by operator precedence).

The qw() quote-like operator allows the definition of a list of strings without typing of quotes and commas. Almost any delimiter can be used instead of parentheses. The following lines are equivalent:

The split function returns a list of strings, which are split from a string expression using a delimiter string or regular expression.

Individual elements of a list are accessed by providing a numerical index in square brackets. The scalar sigil must be used. Sublists (array slices) can also be specified, using a range or list of numeric indices in brackets. The array sigil is used in this case. For example, $month[3] is "April" (the first element in an array has an index value of 0), and @month[4..6] is ("May", "June", "July") .

Perl programmers may initialize a hash (or associative array ) from a list of key/value pairs. If the keys are separated from the values with the => operator (sometimes called a fat comma ), rather than a comma, they may be unquoted (barewords ). The following lines are equivalent:

Individual values in a hash are accessed by providing the corresponding key, in curly braces. The $ sigil identifies the accessed element as a scalar. For example, $favorite{joe} equals 'red' . A hash can also be initialized by setting its values individually:

Multiple elements may be accessed using the @ sigil instead (identifying the result as a list). For example, @favorite{'joe', 'sam'} equals ('red', 'blue') .

Filehandles provide read and write access to resources. These are most often files on disk, but can also be a device, a pipe , or even a scalar value.

Originally, filehandles could only be created with package variables, using the ALL_CAPS convention to distinguish it from other variables. Perl 5.6 and newer also accept a scalar variable, which will be set ( autovivified ) to a reference to an anonymous filehandle, in place of a named filehandle.

A typeglob value is a symbol table entry. The main use of typeglobs is creating symbol table aliases. For example:

The number of elements in an array can be determined either by evaluating the array in scalar context or with the help of the $# sigil. The latter gives the index of the last element in the array, not the number of elements. The expressions scalar( @array ) and ( $#array + 1 ) are equivalent.

There are a few functions that operate on entire hashes. The keys function takes a hash and returns the list of its keys. Similarly, the values function returns a hash's values. Note that the keys and values are returned in a consistent but arbitrary order.

Perl has several kinds of control structures.

It has block-oriented control structures, similar to those in the C, JavaScript , and Java programming languages. Conditions are surrounded by parentheses, and controlled blocks are surrounded by braces:

Where only a single statement is being controlled, statement modifiers provide a more-concise syntax:

Short-circuit logical operators are commonly used to affect control flow at the expression level:

(The "and" and "or" operators are similar to && and || but have lower precedence , which makes it easier to use them to control entire statements.)

The flow control keywords next (corresponding to C's continue ), last (corresponding to C's break ), return , and redo are expressions, so they can be used with short-circuit operators.

Perl also has two implicit looping constructs, each of which has two forms:

grep returns all elements of list for which the controlled block or expression evaluates to true. map evaluates the controlled block or expression for each element of list and returns a list of the resulting values. These constructs enable a simple functional programming style.

Up until the 5.10.0 release, there was no switch statement in Perl 5. From 5.10.0 onward, a multi-way branch statement called given / when is available, which takes the following form:

Syntactically, this structure behaves similarly to switch statements found in other languages, but with a few important differences. The largest is that unlike switch/case structures, given/when statements break execution after the first successful branch, rather than waiting for explicitly defined break commands. Conversely, explicit continue s are instead necessary to emulate switch behavior.

For those not using Perl 5.10, the Perl documentation describes a half-dozen ways to achieve the same effect by using other control structures. There is also a Switch module, which provides functionality modeled on that of sister language Raku . It is implemented using a source filter , so its use is unofficially discouraged.

Perl includes a goto label statement, but it is rarely used. Situations where a goto is called for in other languages don't occur as often in Perl, because of its breadth of flow control options.

There is also a goto &sub statement that performs a tail call . It terminates the current subroutine and immediately calls the specified sub . This is used in situations where a caller can perform more-efficient stack management than Perl itself (typically because no change to the current stack is required), and in deep recursion, tail calling can have substantial positive impact on performance, because it avoids the overhead of scope/stack management on return.

Subroutines are defined with the sub keyword and are invoked simply by naming them. If the subroutine in question has not yet been declared, invocation requires either parentheses after the function name or an ampersand ( & ) before it. But using & without parentheses will also implicitly pass the arguments of the current subroutine to the one called, and using & with parentheses will bypass prototypes.

A list of arguments may be provided after the subroutine name. Arguments may be scalars, lists, or hashes.

The parameters to a subroutine do not need to be declared as to either number or type; in fact, they may vary from call to call. Any validation of parameters must be performed explicitly inside the subroutine.

Arrays are expanded to their elements; hashes are expanded to a list of key/value pairs; and the whole lot is passed into the subroutine as one flat list of scalars.

Whatever arguments are passed are available to the subroutine in the special array @_ . The elements of @_ are references to the actual arguments; changing an element of @_ changes the corresponding argument.

Elements of @_ may be accessed by subscripting it in the usual way.

However, the resulting code can be difficult to read, and the parameters have pass-by-reference semantics, which may be undesirable.

One common idiom is to assign @_ to a list of named variables.

This provides mnemonic parameter names and implements pass-by-value semantics. The my keyword indicates that the following variables are lexically scoped to the containing block.

Another idiom is to shift parameters off of @_ . This is especially common when the subroutine takes only one argument or for handling the $self argument in object-oriented modules.

Subroutines may assign @_ to a hash to simulate named arguments; this is recommended in Perl Best Practices for subroutines that are likely to ever have more than three parameters.

Subroutines may return values.

If the subroutine does not exit via a return statement, it returns the last expression evaluated within the subroutine body. Arrays and hashes in the return value are expanded to lists of scalars, just as they are for arguments.

The returned expression is evaluated in the calling context of the subroutine; this can surprise the unwary.

A subroutine can discover its calling context with the wantarray function.

Perl 5 supports anonymous functions, as follows:

Other constructs take bare blocks as arguments, which serve a function similar to lambda functions of one parameter, but do not have the same parameter-passing convention as functions -- @_ is not set.

The Perl language includes a specialized syntax for writing regular expressions (RE, or regexes), and the interpreter contains an engine for matching strings to regular expressions. The regular-expression engine uses a backtracking algorithm, extending its capabilities from simple pattern matching to string capture and substitution. The regular-expression engine is derived from regex written by Henry Spencer .

The Perl regular-expression syntax was originally taken from Unix Version 8 regular expressions. However, it diverged before the first release of Perl and has since grown to include far more features. Many other languages and applications are now adopting Perl Compatible Regular Expressions over POSIX regular expressions, such as PHP , Ruby , Java , Microsoft's .NET Framework , and the Apache HTTP server .

Regular-expression syntax is extremely compact, owing to history. The first regular-expression dialects were only slightly more expressive than globs , and the syntax was designed so that an expression would resemble the text that it matches. This meant using no more than a single punctuation character or a pair of delimiting characters to express the few supported assertions. Over time, the expressiveness of regular expressions grew tremendously, but the syntax design was never revised and continues to rely on punctuation. As a result, regular expressions can be cryptic and extremely dense.

The m// (match) operator introduces a regular-expression match. (If it is delimited by slashes, as in all of the examples here, the leading m may be omitted for brevity. If the m is present, as in all of the following examples, other delimiters can be used in place of slashes.) In the simplest case, an expression such as

evaluates to true if and only if the string $x matches the regular expression abc .

The s/// (substitute) operator, on the other hand, specifies a search-and-replace operation:

Another use of regular expressions is to specify delimiters for the split function:

The split function creates a list of the parts of the string that are separated by what matches the regular expression. In this example, a line is divided into a list of its own comma-separated parts, and this list is then assigned to the @words array.

Perl regular expressions can take modifiers . These are single-letter suffixes that modify the meaning of the expression:

Because the compact syntax of regular expressions can make them dense and cryptic, the /x modifier was added in Perl to help programmers write more-legible regular expressions. It allows programmers to place whitespace and comments inside regular expressions:

Portions of a regular expression may be enclosed in parentheses; corresponding portions of a matching string are captured . Captured strings are assigned to the sequential built-in variables $1, $2, $3, … , and a list of captured strings is returned as the value of the match.

Captured strings $1, $2, $3, … can be used later in the code.

Perl regular expressions also allow built-in or user-defined functions to apply to the captured match, by using the /e modifier:

There are many ways to write object-oriented code in Perl. The most basic is using "blessed" references . This works by identifying a reference of any type as belonging to a given package, and the package provides the methods for the blessed reference. For example, a two-dimensional point could be defined this way:

This class can be used by invoking new() to construct instances, and invoking distance on those instances.

Many modern Perl applications use the Moose object system. Moose is built on top of Class::MOP, a meta-object protocol, providing complete introspection for all Moose-using classes. Thus you can ask classes about their attributes, parents, children, methods, etc. using a simple API.

Moose classes:

Moose roles:

An example of a class written using the MooseX::Declare extension to Moose:

This is a class named Point3D that extends another class named Point explained in Moose examples . It adds to its base class a new attribute z , redefines the method set_to and extends the method clear .