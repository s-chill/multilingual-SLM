A birthday attack is a bruteforce collision attack that exploits the mathematics behind the birthday problem in probability theory . This attack can be used to abuse communication between two or more parties. The attack depends on the higher likelihood of collisions found between random attack attempts and a fixed degree of permutations ( pigeonholes ). Let H {\textstyle H} be the number of possible values of a hash function, with H = 2 l {\textstyle H=2^{l}} . With a birthday attack, it is possible to find a collision of a hash function with 50 % {\textstyle 50\%} chance in 2 l = 2 l / 2 , {\textstyle {\sqrt {2^{l}}}=2^{l/2},} where l {\textstyle l} is the bit length of the hash output, and with 2 l − 1 {\textstyle 2^{l-1}} being the classical preimage resistance security with the same probability. There is a general (though disputed ) result that quantum computers can perform birthday attacks, thus breaking collision resistance, in 2 l 3 = 2 l / 3 {\textstyle {\sqrt[{3}]{2^{l}}}=2^{l/3}} .

Although there are some digital signature vulnerabilities associated with the birthday attack, it cannot be used to break an encryption scheme any faster than a brute-force attack .

As an example, consider the scenario in which a teacher with a class of 30 students (n = 30) asks for everybody's birthday (for simplicity, ignore leap years ) to determine whether any two students have the same birthday (corresponding to a hash collision as described  further). Intuitively, this chance may seem small. Counter-intuitively, the probability that at least one student has the same birthday as any other student on any day is around 70% (for n = 30), from the formula 1 − 365 ! ( 365 − n ) ! ⋅ 365 n {\displaystyle 1-{\frac {365!}{(365-n)!\cdot 365^{n}}}} .

If the teacher had picked a specific day (say, 16 September), then the chance that at least one student was born on that specific day is 1 − ( 364 / 365 ) 30 {\displaystyle 1-(364/365)^{30}} , about 7.9%.

In a birthday attack, the attacker prepares many different variants of benign and malicious contracts, each having a digital signature . A pair of benign and malicious contracts with the same signature is sought. In this fictional example, suppose that the digital signature of a string is the first byte of its SHA-256 hash. The pair found is indicated in green – note that finding a pair of benign contracts (blue) or a pair of malicious contracts (red) is useless. After the victim accepts the benign contract, the attacker substitutes it with the malicious one and claims the victim signed it, as proven by the digital signature.

In the context of the birthday attack, the key variables are related to the well-known balls and bins problem in probability theory as follows.

The variable n represents the number of inputs (or attempts) being made. In the analogy of the balls and bins problem, n refers to the number of balls that are randomly thrown into H bins. Each input corresponds to throwing a ball into one of the bins (hash values).

The variable H represents the total number of possible outputs of the hash function. This is the number of unique "bins" that the balls can land in. The total number of hash outputs is often expressed as H = 2 l {\displaystyle H=2^{l}} , where l is the bit length of the hash output. In the balls and bins analogy, H represents the number of bins, each corresponding to a unique hash value.

The variable l refers to the bit length of the hash function’s output. Since a hash function of bit length l can produce 2 l {\displaystyle 2^{l}} unique outputs, the number of possible hash values (or bins) is H = 2 l {\displaystyle H=2^{l}} .

The variable p represents the probability that a collision will occur—that is, the probability that two or more inputs (balls) will be assigned the same output (bin). In a birthday attack, p is often set to 0.5 (50%) to estimate how many inputs are needed to have a 50% chance of a collision.

The birthday attack can be modeled as a variation of the balls and bins problem . In this problem:

Given a function f {\displaystyle f} , the goal of the attack is to find two different inputs x 1 , x 2 {\displaystyle x_{1},x_{2}} such that f ( x 1 ) = f ( x 2 ) {\displaystyle f(x_{1})=f(x_{2})} . Such a pair x 1 , x 2 {\displaystyle x_{1},x_{2}} is called a collision. The method used to find a collision is simply to evaluate the function f {\displaystyle f} for different input values that may be chosen randomly or pseudorandomly until the same result is found more than once. Because of the birthday problem, this method can be rather efficient. Specifically, if a function f ( x ) {\displaystyle f(x)} yields any of H {\displaystyle H} different outputs with equal probability and H {\displaystyle H} is sufficiently large, then we expect to obtain a pair of different arguments x 1 {\displaystyle x_{1}} and x 2 {\displaystyle x_{2}} with f ( x 1 ) = f ( x 2 ) {\displaystyle f(x_{1})=f(x_{2})} after evaluating the function for about 1.25 H {\displaystyle 1.25{\sqrt {H}}} different arguments on average.

We consider the following experiment. From a set of H values we choose n values uniformly at random thereby allowing repetitions.  Let p ( n ; H ) be the probability that during this experiment at least one value is chosen more than once. This probability can be approximated as

where n {\displaystyle n} is the number of chosen values (inputs) and H {\displaystyle H} is the number of possible outcomes (possible hash outputs).

Let n ( p ; H ) be the smallest number of values we have to choose, such that the probability for finding a collision is at least p .  By inverting this expression above, we find the following approximation

and assigning a 0.5 probability of collision we arrive at

Let Q ( H ) be the expected number of values we have to choose before finding the first collision. This number can be approximated by

As an example, if a 64-bit hash is used, there are approximately 1.8 × 10 different outputs. If these are all equally probable (the best case), then it would take 'only' approximately 5 billion attempts ( 5.38 × 10 ) to generate a collision using brute force. This value is called birthday bound and for l -bit codes, it could be approximated as 2 Other examples are as follows:

It is easy to see that if the outputs of the function are distributed unevenly, then a collision could be found even faster.  The notion of 'balance' of a hash function quantifies the resistance of the function to birthday attacks (exploiting uneven key distribution.) However, determining the balance of a hash function will typically require all possible inputs to be calculated and thus is infeasible for popular hash functions such as the MD and SHA families. The subexpression ln ⁡ 1 1 − p {\displaystyle \ln {\frac {1}{1-p}}} in the equation for n ( p ; H ) {\displaystyle n(p;H)} is not computed accurately for small p {\displaystyle p} when directly translated into common programming languages as log(1/(1-p)) due to loss of significance .  When log1p is available (as it is in C99 ) for example, the equivalent expression -log1p(-p) should be used instead. If this is not done, the first column of the above table is computed as zero, and several items in the second column do not have even one correct significant digit.

A good rule of thumb which can be used for mental calculation is the relation

which can also be written as

or

This works well for probabilities less than or equal to 0.5.

This approximation scheme is especially easy to use when working with exponents. For instance, suppose you are building 32-bit hashes ( H = 2 32 {\displaystyle H=2^{32}} ) and want the chance of a collision to be at most one in a million ( p ≈ 2 − 20 {\displaystyle p\approx 2^{-20}} ), how many documents could we have at the most?

which is close to the correct answer of 93.

The birthday attack is a method that exploits the mathematics of collisions in hash functions. Below, we provide upper and lower bounds for the probability of a collision, based on the analogy of the balls and bins problem, and derive key equations.

The birthday attack can be modeled as throwing n balls (inputs) into H bins (possible hash outputs). The probability of a collision is bounded by the following equation:

p ≤ n 2 2 H {\displaystyle p\leq {\frac {n^{2}}{2H}}}

This equation follows from the union bound, which gives an upper bound on the probability that at least one collision occurs. We denote the event that the i-th ball collides with one of the previous balls as C i {\displaystyle C_{i}} . The probability of a collision for the i-th ball is:

Pr [ C i ] ≤ i − 1 H {\displaystyle \Pr[C_{i}]\leq {\frac {i-1}{H}}}

Thus, the total probability of a collision after throwing all n balls is bounded by:

p = Pr [ C 1 ∪ C 2 ∪ ⋯ ∪ C n ] ≤ 0 H + 1 H + ⋯ + n − 1 H = n ( n − 1 ) 2 H {\displaystyle p=\Pr[C_{1}\cup C_{2}\cup \cdots \cup C_{n}]\leq {\frac {0}{H}}+{\frac {1}{H}}+\cdots +{\frac {n-1}{H}}={\frac {n(n-1)}{2H}}}

This gives the upper bound for the probability of a collision in a hash function.

The lower bound for the probability of a collision can be derived by assuming no collision after throwing in i balls, which must all occupy different bins. The probability of no collision after throwing the (i+1)-st ball is:

Pr [ D i + 1 | D i ] = H − i H = 1 − i H {\displaystyle \Pr[D_{i+1}|D_{i}]={\frac {H-i}{H}}=1-{\frac {i}{H}}}

The total probability of no collision after throwing all n balls is the product of these terms:

Pr [ D n ] = ∏ i = 1 n − 1 ( 1 − i H ) {\displaystyle \Pr[D_{n}]=\prod _{i=1}^{n-1}\left(1-{\frac {i}{H}}\right)}

By using the inequality 1 − x ≤ e − x {\displaystyle 1-x\leq e^{-x}} , we can approximate this as:

Pr [ D n ] ≤ ∏ i = 1 n − 1 e − i H = e − n ( n − 1 ) 2 H {\displaystyle \Pr[D_{n}]\leq \prod _{i=1}^{n-1}e^{-{\frac {i}{H}}}=e^{-{\frac {n(n-1)}{2H}}}}

Thus, the probability of at least one collision is bounded below by:

p ≥ 1 − e − n ( n − 1 ) 2 H {\displaystyle p\geq 1-e^{-{\frac {n(n-1)}{2H}}}}

This provides the lower bound for the probability of a collision.

It follows from the above argument that the probability of at least one collision is bounded between:

n ( n − 1 ) 4 H ≤ p ≤ n 2 2 H {\displaystyle {\frac {n(n-1)}{4H}}\leq p\leq {\frac {n^{2}}{2H}}}

Letting p ≈ 1 {\displaystyle p\approx 1} , an almost sure collision occurs when the number of trials, n , is given by:

n = Θ ( H ) = Θ ( 2 l / 2 ) {\displaystyle n=\Theta ({\sqrt {H}})=\Theta (2^{l/2})}

This illustrates how the number of inputs required for a collision grows as a function of the bit length of the hash output.

Digital signatures can be susceptible to a birthday attack or more precisely a chosen-prefix collision attack. A message m {\displaystyle m} is typically signed by first computing f ( m ) {\displaystyle f(m)} , where f {\displaystyle f} is a cryptographic hash function , and then using some secret key to sign f ( m ) {\displaystyle f(m)} . Suppose Mallory wants to trick Bob into signing a fraudulent contract. Mallory prepares a fair contract m {\displaystyle m} and a fraudulent one m ′ {\displaystyle m'} . She then finds a number of positions where m {\displaystyle m} can be changed without changing the meaning, such as inserting commas, empty lines, one versus two spaces after a sentence, replacing synonyms, etc. By combining these changes, she can create a huge number of variations on m {\displaystyle m} which are all fair contracts.

In a similar manner, Mallory also creates a huge number of variations on the fraudulent contract m ′ {\displaystyle m'} . She then applies the hash function to all these variations until she finds a version of the fair contract and a version of the fraudulent contract which have the same hash value, f ( m ) = f ( m ′ ) {\displaystyle f(m)=f(m')} . She presents the fair version to Bob for signing. After Bob has signed, Mallory takes the signature and attaches it to the fraudulent contract. This signature then "proves" that Bob signed the fraudulent contract.

The probabilities differ slightly from the original birthday problem, as Mallory gains nothing by finding two fair or two fraudulent contracts with the same hash. Mallory's strategy is to generate pairs of one fair and one fraudulent contract. For a given hash function 2 l {\displaystyle 2^{l}} is the number of possible hashes,  where l {\displaystyle l} is the bit length of the hash output. 
The birthday problem equations do not exactly apply here. For a 50% chance of a collision, Mallory would need to generate approximately 2 ( l / 2 ) + 1 {\displaystyle 2^{(l/2)+1}} hashes, which is twice the number required for a simple collision under the classical birthday problem.

To avoid this attack, the output length of the hash function used for a signature scheme can be chosen large enough so that the birthday attack becomes computationally infeasible, i.e. about twice as many bits as are needed to prevent an ordinary brute-force attack .

Besides using a larger bit length, the signer (Bob) can protect himself by making some random, inoffensive changes to the document before signing it, and by keeping a copy of the contract he signed in his own possession, so that he can at least demonstrate in court that his signature matches that contract, not just the fraudulent one.

Pollard's rho algorithm for logarithms is an example for an algorithm using a birthday attack for the computation of discrete logarithms .

The same fraud is possible if the signer is Mallory, not Bob.  Bob could suggest a contract to Mallory for a signature.  Mallory could find both an inoffensively-modified version of this fair contract that has the same signature as a fraudulent contract, and Mallory could provide the modified fair contract and signature to Bob.  Later, Mallory could produce the fraudulent copy.  If Bob doesn't have the inoffensively-modified version contract (perhaps only finding their original proposal), Mallory's fraud is perfect.  If Bob does have it, Mallory can at least claim that it is Bob who is the fraudster.

Here are additional details:

1. Original Contract Proposal: Bob proposes a fair contract to Mallory, expecting her to sign it.

2. Mallory’s Modified and Fraudulent Contracts: Instead of signing Bob's contract directly, Mallory creates two versions of the contract

3. Mallory Provides the Modified Contract: Mallory signs the modified version and gives it to Bob. The signature on this version is the same as what would appear on the fraudulent contract.

4. Bob’s Risk: If Bob does not keep a copy of the modified version Mallory signed, but only retains the original proposal, he will not have proof of what Mallory agreed to. Later, Mallory can present the fraudulent contract (which carries the same signature) and claim it was the one that was signed.

5. Outcomes: