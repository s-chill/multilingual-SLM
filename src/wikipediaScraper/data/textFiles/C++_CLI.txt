C++/CLI is a variant of the C++ programming language , modified for Common Language Infrastructure .  It has been part of Visual Studio 2005 and later, and provides interoperability with other .NET languages such as C# . Microsoft created C++/CLI to supersede Managed Extensions for C++ . In December 2005, Ecma International published C++/CLI specifications as the ECMA-372 standard.

C++/CLI should be thought of as a language of its own (with a new set of keywords, for example), instead of the C++ superset-oriented Managed C++ (MC++) (whose non-standard keywords were styled like __gc or __value ). Because of this, there are some major syntactic changes, especially related to the elimination of ambiguous identifiers and the addition of .NET-specific features.

Many conflicting syntaxes, such as the multiple versions of operator new () in MC++, have been split: in C++/CLI, .NET reference types are created with the new keyword gcnew (i.e. garbage collected new()). Also, C++/CLI has introduced the concept of generics from .NET (similar, for the most common purposes, to standard C++ templates, but quite different in their implementation).

In MC++, there were two different types of pointers : __nogc pointers were normal C++ pointers, while __gc pointers worked on .NET reference types. In C++/CLI, however, the only type of pointer is the normal C++ pointer, while the .NET reference types are accessed through a "handle", with the new syntax ClassName ^ (instead of ClassName * ). This new construct is especially helpful when managed and standard C++ code is mixed; it clarifies which objects are under .NET automatic garbage collection and which objects the programmer must remember to explicitly destroy.

A tracking reference in C++/CLI is a handle of a passed-by-reference variable. It is similar in concept to using *& (reference to a pointer) in standard C++, and (in function declarations) corresponds to the ref keyword applied to types in C#, or ByRef in Visual Basic .NET . C++/CLI uses a ^% syntax to indicate a tracking reference to a handle.

The following code shows an example of the use of tracking references. Replacing the tracking reference with a regular handle variable would leave the resulting string array with 10 uninitialized string handles, as only copies of the string handles in the array would be set, due to them being passed by value rather than by reference.

Another change in C++/CLI is the introduction of the finalizer syntax ! ClassName () , a special type of nondeterministic destructor that is run as a part of the garbage collection routine . The C++ destructor syntax ~ ClassName () also exists for managed objects, and better reflects the "traditional" C++ semantics of deterministic destruction (that is, destructors that can be called by user code with delete ).

In the raw .NET paradigm, the nondeterministic destruction model overrides the protected Finalize method of the root Object class, while the deterministic model is implemented through the IDisposable interface method Dispose (which the C++/CLI compiler turns the destructor into). Objects from C# or VB.NET code that override the Dispose method can be disposed of manually in C++/CLI with delete just as .NET classes in C++/CLI can.

Operator overloading works analogously to standard C++. Every * becomes a ^, every & becomes anÂ %, but the rest of the syntax is unchanged, except for an important addition: for .NET classes, operator overloading is possible not only for classes themselves, but also for references to those classes. This feature is necessary to give a ref class the semantics for operator overloading expected from .NET ref classes. (In reverse, this also means that for .NET framework ref classes, reference operator overloading often is implicitly implemented in C++/CLI.)

For example, comparing two distinct String references (String^) via the operator == will give true whenever the two strings are equal. The operator overloading is static, however. Thus, casting to Object^ will remove the overloading semantics.

C++/CLI allows C++ programs to consume C# programs in C# DLLs. Here the #using keyword shows the compiler where the DLL is located for its compilation metadata.  This simple example requires no data marshalling .

The C# source code content of MyCS.dll.

This examples shows how strings are marshalled from C++ strings to strings callable from C# then back to C++ strings.  String marshalling copies the string contents to forms usable in the different environments.

The C# code is not in any way C++-aware.

C++/C# interoperability allows C++ simplified access to the entire world of .NET features.

C++/CX targeting WinRT , although it produces entirely unmanaged code, borrows the ref and ^ syntax for the reference-counted components of WinRT, which are similar to COM "objects".