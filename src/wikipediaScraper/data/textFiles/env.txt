env is a shell command for Unix and Unix-like operating systems . It is used to either print a list of environment variables or run another utility in an altered environment without having to modify the currently existing environment. Using env , variables may be added or removed, and existing variables may be changed by assigning new values to them.

In practice, env has another common use. It is often used by shell scripts to launch the correct interpreter . In this usage, the environment is typically not changed.

The version of env bundled in GNU coreutils was written by Richard Mlynarik, David MacKenzie, and Assaf Gordon. It first appeared in 4.4BSD , and is a part of POSIX.1 (with the -i option only).

GNU's env has been extended to handle signals and the current directory. FreeBSD 's env supports a custom search path. Extensions found in both versions include -u , for unsetting variables, and -S , for splitting arguments (mainly in shebang).

To print out the set of current environment variables:

To create a new environment without any existing environment variables for a new shell:

To execute the X application xcalc and have it appear on a different display (i.e., with a modified environment whether the specified environment variable is replaced with the new value):

Note that this use of env is often unnecessary since most shells support setting environment variables in front of a command:

env may also be used in the hashbang line of a script to allow the interpreter to be looked up via the PATH. For example, here is the code of a Python script:

In this example, /usr/bin/env is the full path of the env command. The environment is not altered.

Note that it is possible to specify the interpreter without using env , by giving the full path of the python interpreter. A problem with that approach is that on different computer systems, the exact path may be different. By instead using env as in the example, the interpreter is searched for and located at the time the script is run (more precisely, env does a system call to execvp , which does the job of locating the interpreter and launching it). This makes the script more portable , but also increases the risk that the wrong interpreter is selected because it searches for a match in every directory on the executable search path. It also suffers from the same problem in that the path to the env binary may also be different on a per-machine basis.