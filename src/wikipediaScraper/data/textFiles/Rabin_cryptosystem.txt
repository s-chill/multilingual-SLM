The Rabin cryptosystem is a family of public-key encryption schemes
based on a trapdoor function whose security, like that of RSA , is related to the difficulty of integer factorization .

The Rabin trapdoor function has the advantage that inverting it has been mathematically proven to be as hard as factoring integers, while there is no such proof known for the RSA trapdoor function.
It has the disadvantage that each output of the Rabin function can be generated by any of four possible inputs; if each output is a ciphertext, extra complexity is required on decryption to identify which of the four possible inputs was the true plaintext.
Naive attempts to work around this often either enable a chosen-ciphertext attack to recover the secret key or, by encoding redundancy in the plaintext space, invalidate the proof of security relative to factoring.

Public-key encryption schemes based on the Rabin trapdoor function are used mainly for examples in textbooks.
In contrast, RSA is the basis of standard public-key encryption schemes such as RSAES-PKCS1-v1_5 and RSAES-OAEP that are used widely in practice.

The Rabin trapdoor function was first published as part of the Rabin signature scheme in 1978 by Michael O. Rabin . The Rabin signature scheme was the first digital signature scheme where forging a signature could be proven to be as hard as factoring.

The trapdoor function was later repurposed in textbooks as an example of a public-key encryption scheme, which came to be known as the Rabin cryptosystem even though Rabin never published it as an encryption scheme.

Like all asymmetric cryptosystems, the Rabin system uses a key pair: a public key for encryption and a private key for decryption. The public key is published for anyone to use, while the private key remains known only to the recipient of the message.

The keys for the Rabin cryptosystem are generated as follows:

Then n {\displaystyle n} is the public key and the pair ( p , q ) {\displaystyle (p,q)} is the private key.

A message M {\displaystyle M} can be encrypted by first converting it to a number m < n {\displaystyle m<n} using a reversible mapping, then computing c = m 2 mod n {\displaystyle c=m^{2}{\bmod {n}}} . The ciphertext is c {\displaystyle c} .

The message m {\displaystyle m} can be recovered from the ciphertext c {\displaystyle c} by taking its square root modulo n {\displaystyle n} as follows.

One of these four values is the original plaintext m {\displaystyle m} , although which of the four is the correct one cannot be determined without additional information.

We can show that the formulas in step 1 above actually produce the square roots of c {\displaystyle c} as follows. For the first formula, we want to prove that m p 2 ≡ c mod p {\displaystyle m_{p}^{2}\equiv c{\bmod {p}}} . Since p ≡ 3 mod 4 , {\displaystyle p\equiv 3{\bmod {4}},} the exponent 1 4 ( p + 1 ) {\textstyle {\frac {1}{4}}(p+1)} is an integer. The proof is trivial if c ≡ 0 mod p {\displaystyle c\equiv 0{\bmod {p}}} , so we may assume that p {\displaystyle p} does not divide c {\displaystyle c} . Note that c ≡ m 2 mod p q {\displaystyle c\equiv m^{2}{\bmod {pq}}} implies that c ≡ m 2 mod p {\displaystyle c\equiv m^{2}{\bmod {p}}} , so c is a quadratic residue modulo p {\displaystyle p} . Then

The last step is justified by Euler's criterion .

As an example, take p = 7 {\displaystyle p=7} and q = 11 {\displaystyle q=11} , then n = 77 {\displaystyle n=77} . Take m = 20 {\displaystyle m=20} as our plaintext. The ciphertext is thus c = m 2 mod n = 400 mod 77 = 15 {\displaystyle c=m^{2}{\bmod {n}}=400{\bmod {77}}=15} .

Decryption proceeds as follows:

and we see that r 3 {\displaystyle r_{3}} is the desired plaintext. Note that all four candidates are square roots of 15 mod 77. That is, for each candidate, r i 2 mod 77 = 15 {\displaystyle r_{i}^{2}{\bmod {77}}=15} , so each r i {\displaystyle r_{i}} encrypts to the same value, 15.

The Rabin cryptosystem can be used to create and verify digital signatures . Creating a signature requires the private key ( p , q ) {\displaystyle (p,q)} . Verifying a signature requires the public key n {\displaystyle n} .

A message m {\displaystyle m} can be signed with a private key ( p , q ) {\displaystyle (p,q)} as follows.

A signature ( r , u ) {\displaystyle (r,u)} for a message m {\displaystyle m} can be verified using the public key n {\displaystyle n} as follows.

Decrypting produces three false results in addition to the correct one, so that the correct result must be guessed. This is the major disadvantage of the Rabin cryptosystem and one of the factors which have prevented it from finding widespread practical use.

If the plaintext is intended to represent a text message, guessing is not difficult; however, if the plaintext is intended to represent a numerical value, this issue becomes a problem that must be resolved by some kind of disambiguation scheme. It is possible to choose plaintexts with special structures, or to add padding , to eliminate this problem. A way of removing the ambiguity of inversion was suggested by Blum and Williams: the two primes used are restricted to primes congruent to 3 modulo 4 and the domain of the squaring is restricted to the set of quadratic residues. These restrictions make the squaring function into a trapdoor permutation , eliminating the ambiguity.

For encryption, a square modulo n must be calculated. This is more efficient than RSA , which requires the calculation of at least a cube.

For decryption, the Chinese remainder theorem is applied, along with two modular exponentiations . Here the efficiency is comparable to RSA.

It has been proven that any algorithm which finds one of the possible plaintexts for every Rabin-encrypted ciphertext can be used to factor the modulus n {\displaystyle n} . Thus, Rabin decryption for random plaintext is at least as hard as the integer factorization problem, something that has not been proven for RSA. It is generally believed that there is no polynomial-time algorithm for factoring, which implies that there is no efficient algorithm for decrypting a random Rabin-encrypted value without the private key ( p , q ) {\displaystyle (p,q)} .

The Rabin cryptosystem does not provide indistinguishability against chosen plaintext attacks since the process of encryption is deterministic. An adversary, given a ciphertext and a candidate message, can easily determine whether or not the ciphertext encodes the candidate message (by simply checking whether encrypting the candidate message yields the given ciphertext).

The Rabin cryptosystem is insecure against a chosen ciphertext attack (even when challenge messages are chosen uniformly at random from the message space). By adding redundancies, for example, the repetition of the last 64 bits, the system can be made to produce a single root. This thwarts this specific chosen-ciphertext attack, since the decryption algorithm then only produces the root that the attacker already knows. If this technique is applied, the proof of the equivalence with the factorization problem fails, so it is uncertain as of 2004 if this variant is secure. The Handbook of Applied Cryptography by Menezes, Oorschot and Vanstone considers this equivalence probable, however, as long as the finding of the roots remains a two-part process (1. roots mod p {\displaystyle {\bmod {p}}} and mod q {\displaystyle {\bmod {q}}} and 2. application of the Chinese remainder theorem).