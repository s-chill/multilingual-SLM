mv is a Unix command that moves one or more files or directories from one place to another. If both filenames are on the same filesystem, this results in a simple file rename; otherwise the file content is copied to the new location and the old file is removed. Using mv requires the user to have write permission for the directories the file will move between. This is because mv changes the content of both directories ( i.e. , the source and the target) involved in the move. When using the mv command on files located on the same filesystem, the file's timestamp is not updated.

On UNIX implementations derived from AT&T UNIX , cp , ln and mv are implemented as a single program with hard-linked binaries. The behavior is selected from the path name argv [0] .  This is a common technique by which closely related commands that have been packaged as a unit allow the user to specify the particular course of the intended action.

A move command that moves a directory entry to a new directory was first implemented within Multics . It can be contracted to mv . Later, the mv command appeared in Version 1 Unix and became part of the X/Open Portability Guide issue 2 of 1987. The version of mv bundled in GNU coreutils was written by Mike Parker, David MacKenzie, and Jim Meyering. The command is available as a separate package for Microsoft Windows as part of the UnxUtils collection of native Win32 ports of common GNU Unix-like utilities. The mv command has also been ported to the IBM i operating system.

When a filename is moved to  an existing filename, the existing file is deleted ( clobbered ) by default. If the existing file is not writable but is in a directory that is writable, the mv command asks for confirmation (if run from a terminal) before proceeding, unless the -f (force) option is used.

Accidental overwriting can be prevented using the GNU -n (long format: --no-clobber ) flag. Alternatively, -u ( --update ) only overwrites destination files that are older than source files, -i ( --interactive ) asks for confirmation upon each name conflict, and -b ( --backup ) renames target files out of the way.

A related ambiguity arises when a filename is moved to an existing directory. By default, mv would handle this as one trying to move a name inside this directory. GNU mv has a -T switch for disabling this assumption and try to overwrite the directory instead. An inverse -t makes the move-to-directory operation explicit.

Moving files within the same file system is generally implemented differently than copying the file and then removing the original. On platforms that do not support the rename syscall, a new link is added to the new directory and the original one is deleted. The data of the file is not accessed.  All POSIX -conformant systems implement the rename call.

An actual move (effectively a rename) is dramatically faster than the circuitous copy-and-move procedure.  The file's i-number (short for " inode number") does not change.  No permission is required to read the file being moved insofar as—conceptually speaking—it is only cataloguing information that is being changed as a result of the "move."  Since the source and target directories are being modified, to wit, entries are being created within the target directory and erased from within the source directory, "write" permission in both directories is required to complete the move.  Moving files from one file system to another may fail entirely or may be automatically performed as an atomic copy-and-delete action; the actual details are dependent upon the implementation.

Moving a directory from one parent to a different parent directory requires write permission in the directory being moved, in addition to permissions to modify the old and new parents.  This is because the i-number for the directory entry ".." (which can be used in any context as an alias for the parent of the current directory) changes as a result of the rename.

Most versions of mv support:

These options are a part of X/Open Portability Guidelines, later the basis of POSIX and SUS . All POSIX-compliant mv implementations must support these.

Note that, in the above example, /mnt referred to the directory (the "mount point") over which a given file system is mounted.  Naming such directories /mnt is a popular convention but is by no means necessary. A "file system" can be thought of as an independent tree that is logically regarded as a unit; its root is "mounted" atop a directory of the administrator's choice.  Any previous contents of that directory are invisible, but they are "restored" when the new volume is unmounted.