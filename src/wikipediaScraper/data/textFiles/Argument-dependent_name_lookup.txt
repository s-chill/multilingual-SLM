In the C++ programming language , argument-dependent lookup ( ADL ), or argument-dependent name lookup , applies to the lookup of an unqualified function name depending on the types of the arguments given to the function call . This behavior is also known as Koenig lookup , as it is often attributed to Andrew Koenig , though he is not its inventor.

During argument-dependent lookup, other namespaces not considered during normal lookup may be searched where the set of namespaces to be searched depends on the types of the function arguments. Specifically, the set of declarations discovered during the ADL process, and considered for resolution of the function name, is the union of the declarations found by normal lookup with the declarations found by looking in the set of namespaces associated with the types of the function arguments.

An example of ADL looks like this:

Even though the main function is not in namespace NS, nor is namespace NS in scope, the function NS::f(A&, int) is found because of the declared types of the actual arguments in the function call statement.

A common pattern in the C++ Standard Library is to declare overloaded operators that will be found in this manner. For example, this simple Hello World program would not compile if it weren't for ADL:

Using << is equivalent to calling operator<< without the std:: qualifier.  However, in this case, the overload of operator<< that works for string is in the std namespace, so ADL is required for it to be used.

The following code would work without ADL (which is applied to it anyway):

It works because the output operator for integers is a member function of the std::ostream class, which is the type of cout . 
Thus, the compiler interprets this statement as

which it can resolve during normal lookup. However, consider that e.g. the const char * overloaded operator<< is a non-member function in the std namespace and, thus, requires ADL for a correct lookup:

The std namespace overloaded non-member operator<< function to handle strings is another example:

As Koenig points out in a personal note, without ADL the compiler would indicate an error stating it could not find operator<< as the statement doesn't explicitly specify that it is found in the std namespace.

Functions found by ADL are considered part of a class's interface. In the C++ Standard Library, several algorithms use unqualified calls to swap from within the std namespace. As a result, the generic std::swap function is used if nothing else is found, but if these algorithms are used with a third-party class, Foo , found in another namespace that also contains swap(Foo&, Foo&) , that overload of swap will be used.

While ADL makes it practical for functions defined outside of a class to behave as if they were part of the interface of that class, it makes namespaces less strict and so can require the use of fully qualified names when they would not otherwise be needed. For example, the C++ standard library makes extensive use of unqualified calls to std::swap to swap two values. The idea is that then one can define an own version of swap in one's own namespace and it will be used within the standard library algorithms. In other words, the behavior of

may or may not be the same as the behavior of

(where a and b are of type N::A ) because if N::swap(N::A&, N::A&) exists, the second of the above examples will call it while the first will not. Furthermore, if for some reason both N::swap(N::A&, N::A&) and std::swap(N::A&, N::A&) are defined, then the first example will call std::swap(N::A&, N::A&) but the second will not compile because swap(a, b) would be ambiguous.

In general, over-dependence on ADL can lead to semantic problems. If one library, L1 , expects unqualified calls to foo(T) to have one meaning and another library, L2 expects it to have another, then namespaces lose their utility. If, however, L1 expects L1::foo(T) to have one meaning and L2 does likewise, then there is no conflict, but calls to foo(T) would have to be fully qualified (i.e. L1::foo(x) as opposed to using L1::foo; foo(x); ) lest ADL get in the way.