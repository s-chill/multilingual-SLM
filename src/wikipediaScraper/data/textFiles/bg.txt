In Unix and Unix-like operating systems , job control refers to control of jobs by a shell , especially interactively, where a "job" is a shell's representation for a process group . Basic job control features are the suspending, resuming, or terminating of all processes in the job/process group; more advanced features can be performed by sending signals to the job. Job control is of particular interest in Unix due to its multiprocessing , and should be distinguished from job control generally, which is frequently applied to sequential execution ( batch processing ).

When using Unix or Unix-like operating systems via a terminal (or terminal emulator ), a user will initially only have a single process running, their interactive shell (it may or may not be a login shell). Most tasks (directory listing, editing files, etc.) can easily be accomplished by letting the program take control of the terminal and returning control to the shell when the program exits – formally, by attaching to standard input and standard output to the shell, which reads or writes from the terminal, and catching signals sent from the keyboard, like the termination signal resulting from pressing Control + C .

However, sometimes the user will wish to carry out a task while using the terminal for another purpose. A task that is running but is not receiving input from the terminal is said to be running "in the background", while the single task that is receiving input from the terminal is "in the foreground". Job control is a facility developed to make this possible, by allowing the user to start processes in the background, send already running processes into the background, bring background processes into the foreground, and suspend or terminate processes.

The concept of a job maps the (shell) concept of a single shell command to the (operating system) concept of the possibly many processes that the command entails. Multi-process tasks come about because processes may create additional child processes, and a single shell command may consist of a pipeline of multiple communicating processes. For example, a command to select lines containing the text "title", sort these alphabetically, and display the result in a pager .

This creates at least three processes: one for grep , one for sort , and one for less . Job control allows the shell to control these related processes as one entity, and when a user issues the appropriate key combination (usually Control + Z ), the entire group of processes gets suspended.

Jobs are managed by the operating system as a single process group , and the job is the shell's internal representation of such a group. This is defined in POSIX as:

A set of processes, comprising a shell pipeline, and any processes descended from it, that are all in the same process group.

A job can be referred to by a handle called the job control job ID or simply job ID , which is used by shell builtins to refer to the job. Job IDs begin with the % character; %n identifies job n , while %% identifies the current job. Other job IDs are specified by POSIX . In informal usage the number may be referred to as the "job number" or "job ID", and Bash documentation refers to the (%-prefixed) job ID as the jobspec.

Job control and job IDs are typically only used in interactive use, where they simplify referring to process groups; in scripting PGIDs are used instead, as they are more precise and robust, and indeed job control is disabled by default in bash scripts.

Job control was first implemented in the C shell by Jim Kulp, then at IIASA in Austria, making use of features of the 4.1 BSD kernel.
The KornShell , developed at Bell Labs, adopted it and it was later incorporated into the SVR4 version of the Bourne shell , and exists in most modern Unix shells.

The POSIX standard specifies two commands for resuming suspended jobs in the background and foreground, respectively bg and fg . These were modeled after the Korn shell job control commands.

Typically, the shell keeps a list of jobs in a job table . Recall that a job corresponds to a process group, which consists of all the members of a pipeline and their descendants. The jobs command will list the background jobs existing in the job table, along with their job number and job state (stopped or running). When a session ends when the user logs out (exits the shell, which terminates the session leader process), the shell process sends SIGHUP to all jobs, and waits for the process groups to end before terminating itself.

The disown command can be used to remove jobs from the job table, so that when the session ends the child process groups are not sent SIGHUP, nor does the shell wait for them to terminate. They thus become orphan processes , and may be terminated by the operating system, though more often this is used so the processes are adopted by init (the kernel sets their parent process to init) and continue executing as daemons . Alternatives to prevent jobs from being terminated include nohup and using a terminal multiplexer .

A job running in the foreground can be stopped by typing the suspend character ( Ctrl-Z ). This sends the "terminal stop" signal ( SIGTSTP ) to the process group. By default, SIGTSTP causes processes receiving it to stop, and control is returned to the shell. However, a process can register a signal handler for or ignore SIGTSTP. A process can also be paused with the "stop" signal ( SIGSTOP ), which cannot be caught or ignored.

A job running in the foreground can be interrupted by typing the interruption character ( Ctrl-C ). This sends the "interrupt" signal ( SIGINT ), which defaults to terminating the process, though it can be overridden.

A stopped job can be resumed as a background job with the bg builtin , or as the foreground job with fg . In either case, the shell redirects I/O appropriately, and sends the SIGCONT signal to the process, which causes the operating system to resume its execution. In Bash , a program can be started as a background job by appending an ampersand ( & ) to the command line; its output is directed to the terminal (potentially interleaved with other programs' output), but it cannot read from the terminal input.

A background process that attempts to read from or write to its controlling terminal is sent a SIGTTIN (for input) or SIGTTOU (for output) signal. These signals stop the process by default, but they may also be handled in other ways. Shells often override the default stop action of SIGTTOU so that background processes deliver their output to the controlling terminal by default.

In Bash-compatible shells, the kill builtin (not /bin/kill ) can signal jobs by job ID as well as by process group ID – sending a signal to a job sends it to the whole process group, and jobs specified by a job ID should be killed by prefixing % . kill can send any signal to a job; however, if the intent is to rid the system of the processes the signals SIGKILL and SIGTERM (the default) are probably the most applicable.