The affine cipher is a type of monoalphabetic substitution cipher , where each letter in an alphabet is mapped to its numeric equivalent, encrypted using a simple mathematical function, and converted back to a letter. The formula used means that each letter encrypts to one other letter, and back again, meaning the cipher is essentially a standard substitution cipher with a rule governing which letter goes to which. As such, it has the weaknesses of all substitution ciphers. Each letter is enciphered with the function ( ax + b ) mod 26 , where b is the magnitude of the shift.

Here, the letters of an alphabet of size m are first mapped to the integers in the range 0 ... m − 1 . It then uses modular arithmetic to transform the integer that each plaintext letter corresponds to into another integer that correspond to a ciphertext letter.
The encryption function for a single letter is

where modulus m is the size of the alphabet and a and b are the keys of the cipher. The value a must be chosen such that a and m are coprime . The decryption function is

where a is the modular multiplicative inverse of a modulo m . I.e., it satisfies the equation

The multiplicative inverse of a only exists if a and m are coprime. Hence without the restriction on a , decryption might not be possible.
It can be shown as follows that decryption function is the inverse of the encryption function,

Since the affine cipher is still a monoalphabetic substitution cipher, it inherits the weaknesses of that class of ciphers. The Caesar cipher is an Affine cipher with a = 1 since the encrypting function simply reduces to a linear shift. The Atbash cipher uses a = −1 .

Considering the specific case of encrypting messages in English (i.e. m = 26 ), there are a total of 286 non-trivial affine ciphers, not counting the 26 trivial Caesar ciphers. This number comes from the fact there are 12 numbers that are coprime with 26 that are less than 26 (these are the possible values of a ). Each value of a can have 26 different addition shifts (the b value); therefore, there are 12 × 26 or 312 possible keys. This lack of variety renders the system as highly insecure when considered in light of Kerckhoffs' Principle .

The cipher's primary weakness comes from the fact that if the cryptanalyst can discover (by means of frequency analysis , brute force , guessing or otherwise) the plaintext of two ciphertext characters then the key can be obtained by solving a simultaneous equation . Since we know a and m are relatively prime this can be used to rapidly discard many "false" keys in an automated system.

The same type of transformation used in affine ciphers is used in linear congruential generators , a type of pseudorandom number generator . This generator is not a cryptographically secure pseudorandom number generator for the same reason that the affine cipher is not secure.

In this example showing encryption and decryption, the alphabet is going to be the letters A through Z, and will have the corresponding values found in the following table.

In this encrypting example, the plaintext to be encrypted is "AFFINE CIPHER" using the table mentioned above for the numeric values of each letter, taking a to be 5, b to be 8, and m to be 26 since there are 26 characters in the alphabet being used. Only the value of a has a restriction since it has to be coprime with 26. The possible values that a could be are 1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, and 25. The value for b can be arbitrary as long as a does not equal 1 since this is the shift of the cipher. Thus, the encryption function for this example will be y = E ( x ) = (5 x + 8) mod 26 . The first step in encrypting the message is to write the numeric values of each letter.

Now, take each value of x , and solve the first part of the equation, (5 x + 8) . After finding the value of (5 x + 8) for each character, take the remainder when dividing the result of (5 x + 8) by 26. The following table shows the first four steps of the encrypting process.

The final step in encrypting the message is to look up each numeric value in the table for the corresponding letters. In this example, the encrypted text would be IHHWVCSWFRCP. The table below shows the completed table for encrypting a message in the Affine cipher.

In this decryption example, the ciphertext that will be decrypted is the ciphertext from the encryption example. The corresponding decryption function is D ( y ) = 21( y − b) mod 26 , where a is calculated to be 21, and b is 8. To begin, write the numeric equivalents to each letter in the ciphertext, as shown in the table below.

Now, the next step is to compute 21( y − 8) , and then take the remainder when that result is divided by 26. The following table shows the results of both computations.

The final step in decrypting the ciphertext is to use the table to convert numeric values back into letters. The plaintext in this decryption is AFFINECIPHER. Below is the table with the final step completed.

To make encrypting and decrypting quicker, the entire alphabet can be encrypted to create a one-to-one map between the letters of the cleartext and the ciphertext. In this example, the one-to-one map would be the following:

The following Python code can be used to encrypt text with the affine cipher: