Templates are a feature of the C++ programming language that allows functions and classes to operate with generic types . This allows a function or class declaration to reference via a generic variable another different class (built-in or newly declared data type ) without creating full declaration for each of these different classes.

In plain terms, a templated class or function would be the equivalent of (before "compiling") copying and pasting the templated block of code where it is used, and then replacing the template parameter with the actual one. For this reason, classes employing templated methods place the implementation in the headers (*.h files) as no symbol could be compiled without knowing the type beforehand.

The C++ Standard Library provides many useful functions within a framework of connected templates.

Major inspirations for C++ templates were the parameterized modules provided by the language CLU and the generics provided by Ada .

There are three kinds of templates: function templates , class templates and, since C++14 , variable templates . Since C++11 , templates may be either variadic or non-variadic; in earlier versions of C++ they are always non-variadic.

A function template behaves like a function except that the template can have arguments of many different types (see example). In other words, a function template represents a family of functions. The format for declaring function templates with type parameters is:

Both expressions have the same meaning and behave in exactly the same way. The latter form was introduced to avoid confusion, since a type parameter need not be a class until C++20. (It can be a basic type such as int or double .)

For example, the C++ Standard Library contains the function template max(x, y) which returns the larger of x and y . That function template could be defined like this:

This single function definition works with many data types. Specifically, it works with all data types for which > (the greater-than operator) is defined and returns a value with a type convertible to bool . The usage of a function template saves space in the source code file in addition to limiting changes to one function description and making the code easier to read.

A template does not produce smaller object code, though, compared to writing separate functions for all the different data types used in a specific program. For example, if a program uses both an int and a double version of the max() function template shown above, the compiler will create an object code version of max() that operates on int arguments and another object code version that operates on double arguments. The compiler output will be identical to what would have been produced if the source code had contained two separate non-templated versions of max() , one written to handle int and one written to handle double .

Here is how the function template could be used:

In the first two cases, the template argument T is automatically deduced by the compiler to be int and double , respectively. In the third case automatic deduction of max(3, 7.0) would fail because the type of the parameters must in general match the template arguments exactly. Therefore, we explicitly instantiate the double version with max<double>() .

This function template can be instantiated with any copy-constructible type for which the expression y > x is valid. For user-defined types, this implies that the greater-than operator ( > ) must be overloaded in the type.

Since C++20 , using auto or Concept auto in any of the parameters of a function declaration , that declaration becomes an abbreviated function template declaration. Such a declaration declares a function template and one invented template parameter for each placeholder is appended to the template parameter list:

A class template provides a specification for generating classes based on parameters. Class templates are generally used to implement containers . A class template is instantiated by passing a given set of types to it as template arguments. The C++ Standard Library contains many class templates, in particular the containers adapted from the Standard Template Library , such as vector .

In C++14, templates can be also used for variables, as in the following example:

Although templating on types, as in the examples above, is the most common form of templating in C++, it is also possible to template on values. Thus, for example, a class declared with

can be instantiated with a specific int .

As a real-world example, the standard library fixed-size array type std::array is templated on both a type (representing the type of object that the array holds) and a number which is of type std::size_t (representing the number of elements the array holds). std::array can be declared as follows:

and an array of six char s might be declared:

When a function or class is instantiated from a template, a specialization of that template is created by the compiler for the set of arguments used, and the specialization is referred to as being a generated specialization.

Sometimes, the programmer may decide to implement a special version of a function (or class) for a given set of template type arguments which is called an explicit specialization. In this way certain template types can have a specialized implementation that is optimized for the type or a more meaningful implementation than the generic implementation.

Explicit specialization is used when the behavior of a function or class for particular choices of the template parameters must deviate from the generic behavior: that is, from the code generated by the main template, or templates. For example, the template definition below defines a specific implementation of max() for arguments of type const char* :

C++11 introduced variadic templates , which can take a variable number of arguments in a manner somewhat similar to variadic functions such as std::printf .

C++11 introduced template aliases, which act like parameterized typedefs .

The following code shows the definition of a template alias StrMap . This allows, for example, StrMap<int> to be used as shorthand for std::unordered_map<int,std::string> .

Initially, the concept of templates was not included in some languages, such as Java and C# 1.0. Java's adoption of generics mimics the behavior of templates, but is technically different. C# added generics (parameterized types) in .NET 2.0. The generics in Ada predate C++ templates.

Although C++ templates, Java generics, and .NET generics are often considered similar, generics only mimic the basic behavior of C++ templates. Some of the advanced template features utilized by libraries such as Boost and STLSoft , and implementations of the STL, for template metaprogramming (explicit or partial specialization, default template arguments, template non-type arguments, template template arguments, ...) are unavailable with generics.

In C++ templates, compile-time cases were historically performed by pattern matching over the template arguments. For example, the template base class in the Factorial example below is implemented by matching 0 rather than with an inequality test, which was previously unavailable. However, the arrival in C++11 of standard library features such as std::conditional has provided another, more flexible way to handle conditional template instantiation.

With these definitions, one can compute, say 6! at compile time using the expression Factorial<6>::value .
Alternatively, constexpr in C++11 / consteval in C++20 can be used to calculate such values directly using a function at compile-time. Because of this, template meta-programming is now mostly used to do operations on types.