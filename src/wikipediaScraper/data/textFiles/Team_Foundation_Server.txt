Azure DevOps Server , formerly known as Team Foundation Server ( TFS ) and Visual Studio Team System ( VSTS ), is a Microsoft product that provides version control (either with Team Foundation Version Control (TFVC) or Git ), reporting, requirements management , project management (for both agile software development and waterfall teams ), automated builds, testing and release management capabilities. It covers the entire application lifecycle and enables DevOps capabilities. Azure DevOps can be used as a back-end to numerous integrated development environments (IDEs) but is tailored for Microsoft Visual Studio and Eclipse on all platforms.

Azure DevOps is available in two different forms: on-premises ("Server") and online ("Services"). The latter form is called Azure DevOps Services (formerly Visual Studio Online before it was renamed to Visual Studio Team Services in 2015). The cloud service is backed by the Microsoft Azure cloud platform. It uses the same code as the on-premises version of Azure DevOps, with minor modifications, and implements the most recent features. A user signs in using a Microsoft account to set up an environment, creating projects and adding team members. New features developed in short development cycles are added to the cloud version first. These features migrate to the on-premises version as updates, at approximately three-month intervals.

Azure DevOps is built on multi-tier , scalable architecture. The primary structure consists of an application tier responsible for processing logic and maintaining the web application portal (referred to as Team Web Access or TWA). Azure DevOps is built using Windows Communication Foundation web services. These may be consumed by any client, although the client object model is recommended. The data tier and application tier can exist on the same machine.

To support scalability, the application tier can be load balanced and the data tier can be clustered. If using Microsoft SQL Server 2012 or later, AlwaysOn SQL Server Failover Clusters and Availability Groups are supported which allows for geographic replication of data. The primary container is the project collection. A project collection is a database that contains a group of Team Projects. The Project Collection is another scalability mechanism, in that each collection can be placed on different SQL Servers or SQL Server instances. 'Oe' configuration database per Azure DevOps instance stores project collection metadata. Data from the project collection databases is aggregated into the warehouse database, which denormalizes the data in preparation for loading into an Analysis Services cube. The warehouse and the cube allow complex trend reporting and data analysis.

Azure DevOps can integrate with an existing SharePoint farm. SQL Server Reporting Services are supported for more advanced reporting against the data warehouse or the Analysis Services data cube. These installations can be on the same system or on different systems. Build servers, lab management servers, release management servers and proxy servers (to reduce some of the load on the application tier), test machines and load test machines can also be added to the infrastructure. To support teams requiring enterprise project scheduling, Azure DevOps also integrates with Microsoft Project Server , which allows enterprise level portfolio management, resource management and project tracking.

Microsoft provides two standalone redistributed APIs for connecting to Azure DevOps. One is a Java SDK, the other is a .NET Framework SDK. These APIs allow for client connectivity to Azure DevOps. Because Azure DevOps is written on a service-oriented architecture , it can communicate with virtually any tool that can call a web service. Another extensible mechanism is subscribing to system alerts: for example, alerts that a work item was changed, or a build completed. There are approximately 20 preconfigured alerts, and teams can configure as many additional alerts as needed. When used in an extensible scenario, these alerts can be sent to a web service, triggering actions to alter or update work items (such as implementing advanced business rules or generating work items programmatically based on a given scenario).

The data warehouse can also be extended through the creation of custom data warehouse adapters. With the introduction of TFS 2012, custom add-ins can also be created for Team Web Access, called Web Access Extensions .

Azure DevOps supports Visual Studio 2010 and later, Microsoft Test Manager (MTM) 2012, and 2013. Eclipse, older versions of Visual Studio, and other environments can be plugged into Azure DevOps using the Microsoft Source Code Control Integration Provider (MSSCCI Provider – pronounced “Miss-Key”). These tools provide full access to the features in Azure DevOps.

Microsoft Excel and Microsoft Project are also supported to help manage work items which allows for bulk update, bulk entry and bulk export of work items. Microsoft Project can be used to schedule work when conforming to a waterfall software development methodology. Both Excel and Project support bi-directional updates of data. This allows, for example, project managers to put a schedule in Project, have that work imported into Azure DevOps where developers update the work and then the schedule can be updated without the project manager having to perform extra work.

With Team Foundation Server 2012, Microsoft PowerPoint was also integrated with Azure DevOps to enable rapid storyboard development to help with the requirements management process. The integration provides extensible storyboard shapes that can be used to build any type of interface mockup that can then be animated with PowerPoint's built-in functions. These storyboards can then be linked to work items.

In an effort to handle the growing geographic dispersion of teams and to involve stakeholders earlier and more often in the process, Microsoft added the Feedback Client. This tool allows users to exercise an application, annotate what they are seeing with audio and video, capture screens and provide contextual feedback to the development team. This provides specific feedback on the functions of an application from a users’ perspective without requiring meetings and demonstration sessions. Azure DevOps also provides for command line tools for both Unix and Windows environments. The Power Tools for TFS include a Windows shell integration that allows users to check files in and out, add files and perform other basic tasks by right-clicking on a file or folder.

At the heart of Azure DevOps is the "work item". A work item represents a thing – it can be work that needs to be accomplished, a risk to track, a test case, a bug or virtually anything else a user can imagine. Work items are defined through the XML documents and are highly extensible. Work items are combined into a Process Template that contains these and other pieces of information to provide a development framework. Azure DevOps includes Process Templates for the Microsoft Solutions Framework for Agile, Scrum and CMMI. Teams can choose to use a built-in template or one of the many templates available for use created by third parties. Process templates can be customized using the Process Template Editor, which is part of the Power Tools.

Work items can be linked to each other using different relationships to create a hierarchical tree of work items or a flat relationship between work items. Work items can also be linked to external artifacts such as web pages, documents on a file share or documents stored in another repository such as SharePoint. Work items can also be linked to source code, build results, test results and specific versions of items in source control.

The flexibility in the work item system allows Azure DevOps to play many roles from requirements management to bug tracking, risk and issue tracking, as well as recording the results of reviews. The extensible linking capabilities ensure that traceability from requirements to source code to test cases and results can be accomplished and reported on for auditing purposes as well as historical understanding of changes.

Azure DevOps supports two different types of source control – its original source control engine called Team Foundation Version Control (TFVC) and with the release of TFS 2013, it supports Git as a core source control repository.

TFVC is a centralized version control system allowing teams to store any type of artifact within its repository. TFVC supports two different types of workspaces when working with client tools – Server Workspaces and Local Workspaces. Server workspaces allow developers to lock files for check-out and provide notification to other developers that files are being edited. A frequent complaint for this model is that files on the development machine are marked as read-only. It also requires developers to "go offline" when the server can't be contacted. Local workspaces were designed to avoid these problems. In a local workspace scenario files are not read-only and they do not have to be checked out before working on them. As long as the files are on the developer's local machine, it doesn't matter if the server is connected or not. Conflicts are dealt with at check-in time.

To improve performance for remote clients, Azure DevOps includes the ability to install Proxy Servers . Proxy servers allow source control contents to be cached at a site closer to the developers to avoid long network trips and the associated latency. Check-ins are still performed directly against the Azure DevOps application tier so the Proxy Server is most beneficial in read scenarios.

As part of the source control engine, Azure DevOps supports a number of features to help developers ensure the code that is checked in follows configurable rules. This rule engine is called a Check-in Policy. There are several out of the box policies such as the Changeset Comments Policy which will not allow a check-in unless the developer enters a check-in comment. These policies are extensible and can be used to examine all aspects of the code being checked in, the comments and the related work items. Azure DevOps also supports a Code Analysis feature that when used independently is known as FxCop . The inclusion in Azure DevOps means that the analysis can run against code checked into the server and during automated builds.

The Azure Repos extension for Visual Studio Code supports TFVC.

With the release of TFS 2013, Microsoft added native support for Git . This is not a Microsoft specific implementation but a standard implementation based on the libgit2 library. This is the same library that powers the popular GitHub and the code is freely available from GitHub. Because Microsoft took the approach of using a standard library, any Git client can now be used natively with Azure DevOps (in other words, developers can use their favorite tools and never install the standard Azure DevOps clients). This allows tools on any platform and any IDE that support Git to connect to Azure DevOps. For example, both Xcode and Android Studio support Git plug-ins. In addition, if developers do not want to use Microsoft's Team Explorer Everywhere plug-in for Eclipse , they can choose to use eGit to connect to Azure DevOps.

Using Git does not preclude the benefit of using Azure DevOps work item or build system. When checking code in with Git, referencing the work item ID in the check-in comment will associate the check-in with the given work item. Likewise, Team Build will also build Git projects.

One of the major reasons to use Azure DevOps as a Git repository is that it is backed by SQL Server and is afforded the same protection as Team Foundation Version Control (TFVC) . This gives developers some choices when choosing the type of project and work style that works best for them.

Reporting has been a core component of Azure DevOps since its initial release in 2005. The reporting infrastructure consists of a data warehouse (Tfs_Warehouse) which is a relational database and a SQL Server Analysis Services data cube. Both of these sources are available for reporting through SQL Server Reporting Services when this option is installed. Since these are standard database and cube structures, any tool which can point to these data sources can report from them. This includes tools such as Cognos, Tableau, Excel and other reporting tools. Included with each out of the box process template is a set of reports for reporting services which cover Build information, Test results and progress, project management, agile reports (Backlog Overview, Release Burndown, Sprint Burndown and Velocity), bug and issue data. New reports can be created using Report Builder for SSRS and any of the existing reports can be modified.

More specialized reporting is available for load test results. This data is available directly within Visual Studio and can be exported to Excel for detailed analysis.

TFS 2013 introduced a new feature called "light-weight reporting" which provides for the ability to create real-time reports based on query results and which do not rely on the warehouse or cube. TFS 2012 (and continuing into 2013) offers real-time burndown, velocity and CFD diagrams directly within Team Web Access.

Team Build (prior to TFS 2015) is a build server application included with Team Foundation Server. Two components make up Team Build – MSBuild and Windows Workflow Foundation . MSBuild is a declarative XML language similar to Apache Ant . WF was added to the build process starting with TFS 2010; prior to that only MSBuild was available. The build capabilities have continued to evolve with each subsequent release of Azure DevOps. In TFS 2010 and 2012, the WF templates ( Extensible Application Markup Language ) files were stored in source control and could be edited and versioned directly from source control. In TFS 2013, these files were removed to eliminate clutter and streamline the build process. The WF templates can still be downloaded, edited and stored in source control if desired and TFS 2013 does not break existing TFS 2010 or 2012 build process templates. With the support of Git in TFS 2013, Team Build has been enhanced to allow automated building of Git projects as well as TFVC projects.

Windows Workflow controls the overall flow of the build process and Azure DevOps includes many pre-built workflow activities for managing common tasks that are performed during a build. MSBuild is the markup language that is found in the .proj (csproj for C# projects and vbproj for Visual Basic projects) files. The build system is extensible with users being able to create their own workflow activities, the ability to inject MSBuild into the process and to execute external processes. The workflow nature of the build allows for unlimited flexibility, but it may take some work to achieve that flexibility. Shared and open source projects have been started to build community backed activities to enhance the capabilities of Team Build.

The build process can be configured for various types of builds including scheduled builds, continuous integration , gated check-in and rolling builds. A gated check-in build will shelve code that a developer checks in, perform a "get latest" on the server code and perform a build. If the build succeeds, the code is checked in on behalf of the developer who submitted the code. If the build fails, the developer is notified and can fix the code before trying another check-in.

Builds have retention policies with them so that they do not accumulate when not needed (or builds can be directed not to produce any saved output) or build output can be locked and saved forever. New with TFS 2013 is the ability to check in the build results into source control. This was a necessary enhancement to support automated builds on the Azure DevOps Services where there is no drop location to place the builds. In the on-premises version build output can be configured to end up in any accessible shared folder location.

The build process in Azure DevOps is also part of the traceability mechanism in that Team Build brings together many of the artifacts that are created and stored in Azure DevOps. Assuming developers associate source code with work items on check-in, Team Build has the ability to report on the changes in each build – both source code changes and work item changes as well as test results (this includes unit testing results as well as automated functional testing (CodedUI) results). As bugs and PBIs are resolved and integrated into builds, the work items which track these artifacts are automatically updated to indicate in which build they were successfully integrated. Combined with the testing tools, testers then get an integrated view of what code was changed in each build, but also which bugs, PBIs and other work changed from build to build.

Initially, in TFS 2015 and with Visual Studio Team Services (VSTS), Microsoft has reinvented the architecture for the build engine to be based on a cross-platform friendly Node.js application. Windows, Mac, and Linux build agents are currently supported. Azure DevOps provides for elastic build capabilities via build hosting in Microsoft Azure.

In mid-2013 Microsoft purchased a product called InRelease from InCycle Software. InRelease was fully incorporated into Team Foundation Server 2013. This capability complemented the automated build and testing processes by allowing a true continuous deployment solution. The tools were re-branded "Release Management" for TFS 2013. The Release Management capabilities give teams the ability to perform a controlled, workflow (provided by Windows Workflow Foundation ) driven release to development, test and production environments and provides dashboards for monitoring the progress of one or more releases.

Microsoft has rebuilt Release Management for Visual Studio Team Services and on-premises version of TFS with the new changes in 2015 Update 2. The new version of Release Management leverages the web browser as the client and relies on the same agent architecture as Team Foundation Build. Release Management enables DevOps capabilities for Azure DevOps.

This first version of Team Foundation Server was released March 17, 2006.