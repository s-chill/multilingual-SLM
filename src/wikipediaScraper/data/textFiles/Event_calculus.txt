The event calculus is a logical theory for representing and reasoning about events and about the way in which they change the state of some real or artificial world. It deals both with action events, which are performed by agents, and with external events, which are outside the control of any agent.

The event calculus represents the state of the world at any time by the set of all the facts (called fluents ) that hold at the time. Events initiate and terminate fluents:

A fluent holds at a time if the fluent is initiated by an event that happens at an earlier time and the fluent is not terminated by any event that happens in the meantime.

The event calculus differs from most other approaches for reasoning about change by reifying time, associating events with the time at which they happen, and associating fluents with the times at which they hold.

The original version of the event calculus, introduced by Robert Kowalski and Marek Sergot in 1986, was formulated as a logic program and developed for representing narratives and database updates. Kave Eshghi showed how to use the event calculus for planning, by using abduction to generate hypothetical actions to achieve a desired state of affairs.

It was extended by Murray Shanahan and Rob Miller in the 1990s and reformulated in first-order logic with circumscription .
These and later extensions have been used to formalize non-deterministic actions, concurrent actions, actions with delayed effects, gradual changes, actions with duration, continuous change, and non-inertial fluents.

Van Lambalgen and Hamm showed how a formulation of the event calculus as a constraint logic program can be used to give an algorithmic semantics to tense and aspect in natural language.

In the event calculus, fluents are reified . This means that fluents are represented by terms . For example, h o l d s A t ( o n ( g r e e n _ b l o c k , t a b l e ) , 1 ) {\displaystyle {\mathit {holdsAt}}(on(green\_block,table),1)} expresses that the g r e e n _ b l o c k {\displaystyle {\mathit {green\_block}}} is on the t a b l e {\displaystyle {\mathit {table}}} at time 1 {\displaystyle 1} . Here h o l d s A t {\displaystyle {\mathit {holdsAt}}} is a predicate, while o n ( g r e e n _ b l o c k , t a b l e ) {\displaystyle {\mathit {on(green\_block,table)}}} is a term. In general, the atomic formula

Events are also reified and represented by terms. For example, h a p p e n s A t ( m o v e ( g r e e n _ b l o c k , r e d _ b l o c k ) , 3 ) {\displaystyle {\mathit {happensAt}}(move(green\_block,red\_block),3)} expresses that the g r e e n _ b l o c k {\displaystyle {\mathit {green\_block}}} is moved onto the r e d _ b l o c k ) {\displaystyle {\mathit {red\_block)}}} at time 3 {\displaystyle 3} . In general:

The relationships between events and the fluents that they initiate and terminate are also represented by atomic formulae:

The event calculus was developed in part as an alternative to the situation calculus , as a solution to the frame problem , of representing and reasoning about the way in which actions and other events change the state of some world.

There are many variants of the event calculus. But the core axiom of one of the simplest and most useful variants can be expressed as a single, domain-independent axiom:

The axiom states that

The event calculus solves the frame problem by interpreting this axiom in a non-monotonic logic , such as first-order logic with circumscription or, as a logic program , in Horn clause logic with negation as failure . In fact, circumscription is one of the several semantics that can be given to negation as failure, and it is closely related to the completion semantics for logic programs (which interprets if as if and only if ).

The core event calculus axiom defines the h o l d s A t {\displaystyle holdsAt} predicate in terms of the h a p p e n s A t {\displaystyle happensAt} , i n i t i a t e s {\displaystyle initiates} , t e r m i n a t e s {\displaystyle terminates} , < {\displaystyle <} and ≤ {\displaystyle \leq } predicates. To apply the event calculus to  a particular problem, these other predicates also need to be defined.

The event calculus is compatible with different definitions of the temporal predicates < {\displaystyle <} and ≤ {\displaystyle \leq } . In most applications, times are represented discretely, by the natural numbers, or continuously, by non-negative real numbers. However, times can also be partially ordered.

To apply the event calculus in a particular problem domain, it is necessary to define the i n i t i a t e s {\displaystyle initiates} and t e r m i n a t e s {\displaystyle terminates} predicates for that domain. For example, in the blocks world domain, an event m o v e ( O b j e c t , P l a c e ) {\displaystyle move(Object,Place)} of moving an object onto a place intitiates the fluent o n ( O b j e c t , P l a c e ) {\displaystyle on(Object,Place)} , which expresses that the object is on the place and terminates the fluent o n ( O b j e c t , P l a c e 1 ) {\displaystyle on(Object,Place1)} , which expresses that the object is on a different place:

If we want to represent the fact that a F l u e n t {\displaystyle Fluent} holds in an initial state, say at time 1, then with the simple core axiom above we need an event, say i n i t i a l i s e ( F l u e n t ) {\displaystyle initialise(Fluent)} , which initiates the F l u e n t {\displaystyle Fluent} at any time:

To apply the event calculus, given the definitions of the h o l d s A t {\displaystyle holdsAt} , i n i t i a t e s {\displaystyle initiates} , t e r m i n a t e s {\displaystyle terminates} , < {\displaystyle <} and ≤ {\displaystyle \leq } predicates, it is necessary to define the h a p p e n s A t {\displaystyle happensAt} predicates that describe the specific context of the problem.

For example, in the blocks world domain, we might want to describe an initial state in which there are two blocks, a red block on a green block on a table, like a toy traffic light, followed by moving the red block to the table at time 1 and moving the green block onto the red block at time 3, turning the traffic light upside down:

The event calculus has a natural implementation in pure Prolog (without any features that do not have a logical interpretation). For example, the blocks world scenario above can be implemented (with minor modifications) by the program:

The Prolog program differs from the earlier formalisation in the following ways:

Given an appropriate definition of the predicate before ( Time1 , Time2 ), the Prolog program generates all answers to the query what holds when? in temporal order:

The program can also answer negative queries, such as which fluents do not hold at which times? However, to work correctly, all variables in negative conditions must first be instantiated to terms containing no variables. For example:

In addition to Prolog and its variants, several other tools for reasoning using the event calculus are also available:

Notable extensions of the event calculus include Markov logic networks–based variants probabilistic , epistemic and their combinations.