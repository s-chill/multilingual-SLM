In computer programming languages , a switch statement is a type of selection control mechanism used to allow the value of a variable or expression to change the control flow of program execution via search and map.

Switch statements function somewhat similarly to the if statement used in programming languages like C / C++ , C# , Visual Basic .NET , Java and exist in most high-level imperative programming languages such as Pascal , Ada , C / C++ , C# , Visual Basic .NET , Java , and in many other types of language, using such keywords as switch , case , select or inspect .

Switch statements come in two main variants: a structured switch, as in Pascal, which takes exactly one branch, and an unstructured switch, as in C, which functions as a type of goto . The main reasons for using a switch include improving clarity, by reducing otherwise repetitive coding, and (if the heuristics permit) also offering the potential for faster execution through easier compiler optimization in many cases.

In his 1952 text Introduction to Metamathematics , Stephen Kleene formally proved that the CASE function (the IF-THEN-ELSE function being its simplest form) is a primitive recursive function , where he defines the notion "definition by cases" in the following manner:

"#F. The function φ defined thus

where Q 1 , ... , Q m are mutually exclusive predicates (or φ(x 1 , ... , x n ) shall have the value given by the first clause which applies) is primitive recursive in φ 1 , ..., φ m+1 , Q 1 , ..., Q m+1 .

Kleene provides a proof of this in terms of the Boolean-like recursive functions "sign-of" sg( ) and "not sign of" ~sg( ) (Kleene 1952:222-223); the first returns 1 if its input is positive and −1 if its input is negative.

Boolos-Burgess-Jeffrey make the additional observation that "definition by cases" must be both mutually exclusive and collectively exhaustive . They too offer a proof of the primitive recursiveness of this function (Boolos-Burgess-Jeffrey 2002:74-75).

The IF-THEN-ELSE is the basis of the McCarthy formalism : its usage replaces both primitive recursion and the mu-operator .

The earliest Fortran compilers supported the computed GOTO statement for multi-way branching.  Early ALGOL compilers supported a SWITCH data type which contains a list of "designational expressions".  A GOTO statement could reference a switch variable and, by providing an index, branch to the desired destination.  With experience it was realized that a more formal multi-way construct, with single point of entrance and exit, was needed.  Languages such as BCPL , ALGOL-W , and ALGOL-68 introduced forms of this construct which have survived through modern languages.

In most languages, programmers write a switch statement across many individual lines using one or two keywords. A typical syntax involves:

Each alternative begins with the particular value, or list of values (see below), that the control variable may match and which will cause the control to goto the corresponding sequence of statements. The value (or list/range of values) is usually separated from the corresponding statement sequence by a colon or by an implication arrow. In many languages, every case must also be preceded by a keyword such as case or when .

An optional default case is typically also allowed, specified by a default , otherwise , or else keyword. This executes when none of the other cases match the control expression. In some languages, such as C, if no case matches and the default is omitted the switch statement simply does nothing. In others, like PL/I, an error is raised.

Semantically, there are two main forms of switch statements.

The first form are structured switches, as in Pascal, where exactly one branch is taken, and the cases are treated as separate, exclusive blocks. This functions as a generalized if–then–else conditional , here with any number of branches, not just two.

The second form are unstructured switches, as in C, where the cases are treated as labels within a single block, and the switch functions as a generalized goto. This distinction is referred to as the treatment of fallthrough, which is elaborated below.

In many languages, only the matching block is executed, and then execution continues at the end of the switch statement. These include the Pascal family (Object Pascal, Modula, Oberon, Ada, etc.) as well as PL/I , modern forms of Fortran and BASIC dialects influenced by Pascal, most functional languages, and many others. To allow multiple values to execute the same code (and avoid needing to duplicate code ), Pascal-type languages permit any number of values per case, given as a comma-separated list, as a range, or as a combination.

Languages derived from C language, and more generally those influenced by Fortran's computed GOTO , instead feature fallthrough, where control moves to the matching case, and then execution continues ("falls through") to the statements associated with the next case in the source text. This also allows multiple values to match the same point without any special syntax: they are just listed with empty bodies. Values can be special conditioned with code in the case body. In practice, fallthrough is usually prevented with a break keyword at the end of the matching body, which exits execution of the switch block, but this can cause bugs due to unintentional fallthrough if the programmer forgets to insert the break statement. This is thus seen by many as a language wart, and warned against in some lint tools. Syntactically, the cases are interpreted as labels, not blocks, and the switch and break statements explicitly change control flow. Some languages influenced by C, such as JavaScript , retain default fallthrough, while others remove fallthrough, or only allow it in special circumstances. Notable variations on this in the C-family include C# , in which all blocks must be terminated with a break or return unless the block is empty (i.e. fallthrough is used as a way to specify multiple values).

In some cases languages provide optional fallthrough. For example, Perl does not fall through by default, but a case may explicitly do so using a continue keyword. This prevents unintentional fallthrough but allows it when desired. Similarly, Bash defaults to not falling through when terminated with ;; , but allows fallthrough with ;& or ;;& instead.

An example of a switch statement that relies on fallthrough is Duff's device .

Optimizing compilers such as GCC or Clang may compile a switch statement into either a branch table or a binary search through the values in the cases. A branch table allows the switch statement to determine with a small, constant number of instructions which branch to execute without having to go through a list of comparisons, while a binary search takes only a logarithmic number of comparisons, measured in the number of cases in the switch statement.

Normally, the only method of finding out if this optimization has occurred is by actually looking at the resultant assembly or machine code output that has been generated by the compiler.

In some languages and programming environments, the use of a case or switch statement is considered superior  to an equivalent series of if else if statements because it is:

Additionally, an optimized implementation may execute much faster than the alternative, because it is often implemented by using an indexed branch table . For example, deciding program flow based on a single character's value, if correctly implemented, is vastly more efficient than the alternative, reducing instruction path lengths considerably. When implemented as such, a switch statement essentially becomes a perfect hash .

In terms of the control-flow graph , a switch statement consists of two nodes (entrance and exit), plus one edge between them for each option. By contrast, a sequence of "if...else if...else if" statements has an additional node for every case other than the first and last, together with a corresponding edge. The resulting control-flow graph for the sequences of "if"s thus has many more nodes and almost twice as many edges, with these not adding any useful information. However, the simple branches in the if statements are individually conceptually easier than the complex branch of a switch statement. In terms of cyclomatic complexity , both of these options increase it by k −1 if given k cases.

Switch expressions are introduced in Java SE 12 , 19 March 2019, as a preview feature.
Here a whole switch expression can be used to return a value.
There is also a new form of case label, case L-> where the right-hand-side is a single expression.
This also prevents fall through and requires that cases are exhaustive.
In Java SE 13 the yield statement is introduced, and in Java SE 14 switch expressions become a standard language feature. For example:

Many languages evaluate expressions inside switch blocks at runtime, allowing a number of less obvious uses for the construction. This prohibits certain compiler optimizations, so is more common in dynamic and scripting languages where the enhanced flexibility is more important than the performance overhead.

For example, in PHP , a constant can be used as the "variable" to check against, and the first case statement which evaluates to that constant will be executed:

This feature is also useful for checking multiple variables against one value rather than one variable against many values.
COBOL also supports this form (and other forms) in the EVALUATE statement.
PL/I has an alternative form of the SELECT statement where the control expression is omitted altogether and the first WHEN that evaluates to true is executed.

In Ruby , due to its handling of === equality, the statement can be used to test for variable’s class:

Ruby also returns a value that can be assigned to a variable, and doesn’t actually require the case to have any parameters (acting a bit like an else if statement):

A switch statement in assembly language :

For Python 3.10.6, PEPs 634-636 were accepted, which added match and case keywords. Unlike other languages, Python notably doesn't exhibit fallthrough behavior.

A number of languages implement a form of switch statement in exception handling , where if an exception is raised in a block, a separate branch is chosen, depending on the exception. In some cases a default branch, if no exception is raised, is also present. An early example is Modula-3 , which use the TRY ... EXCEPT syntax, where each EXCEPT defines a case. This is also found in Delphi , Scala , and Visual Basic .NET .

Some alternatives to switch statements can be: