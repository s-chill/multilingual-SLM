ASP.NET Web Forms is a web application framework and one of several programming models supported by the Microsoft ASP.NET technology. Web Forms applications can be written in any programming language which supports the Common Language Runtime , such as C# or Visual Basic . The main building blocks of Web Forms pages are server controls , which are reusable components responsible for rendering HTML markup and responding to events. A technique called view state is used to persist the state of server controls between normally stateless HTTP requests.

Web Forms was included in the original .NET Framework 1.0 release in 2002 (see .NET Framework version history and ASP.NET version history ), as the first programming model available in ASP.NET. Unlike newer ASP.NET components, Web Forms is not supported by ASP.NET Core .

ASP.NET web pages, known officially as Web Forms, were the main building blocks for application development in ASP.NET before the introduction of MVC. There are two basic methodologies for Web Forms: a web application format and a web site format. Web applications need to be compiled before deployment, while web sites allow the user to copy the files directly to the server without prior compilation. Web forms are contained in files with a ".aspx" extension; these files typically contain static ( X ) HTML markup or component markup. The component markup can include server-side Web Controls and User Controls that have been defined in the framework or the web page. For example, a textbox component can be defined on a page as <asp:textbox id='myid' runat='server'> , which is rendered into an html input box. Additionally, dynamic code, which runs on the server, can be placed in a page within a block <% -- dynamic code -- %> , which is similar to other Web development technologies such as PHP , JSP , and ASP . With ASP.NET Framework 2.0 , Microsoft introduced a new code-behind model that lets static text remain on the .aspx page while dynamic code goes into an .aspx.vb or .aspx.cs or .aspx.fs file (depending on the programming language used).

Microsoft recommends dealing with dynamic program code by using the code-behind model, which places this code in a separate file or in a specially designated script tag. Code-behind files typically have names like " MyPage.aspx.cs" or " MyPage.aspx.vb" while the page file is MyPage.aspx (same filename as the page file (ASPX), but with the final extension denoting the page language). This practice is automatic in Visual Studio and other IDEs , though the user can change the code-behind page name. Also, in the web application format, the pagename.aspx.cs is a partial class that is linked to the pagename.designer.cs file. The designer file is a file that is autogenerated from the ASPX page and allows the programmer to reference components in the ASPX page from the code-behind page without having to declare them manually, as was necessary in ASP.NET versions before version 2. When using this style of programming, the developer writes code to respond to different events, such as the page being loaded, or a control being clicked, rather than a procedural walkthrough of the document.

ASP.NET's code-behind model marks a departure from Classic ASP in that it encourages developers to build applications with separation of presentation and content in mind. In theory, this would allow a Web designer, for example, to focus on the design markup with less potential for disturbing the programming code that drives it. This is similar to the separation of the controller from the view in model–view–controller (MVC) frameworks.

A directive is a special instruction on how ASP.NET should process the page. The most common directive is <%@ Page %> , which can specify many attributes used by the ASP.NET page parser and compiler.

User controls are encapsulations of sections of page sections that are registered and used as controls in ASP.NET.

Programmers can also build custom controls for ASP.NET applications. Unlike user controls, these controls do not have an ASCX markup file, having all their code compiled into a dynamic link library (DLL) file. Such custom controls can be used across multiple Web applications and Visual Studio 2013 projects.

.NET uses a "visited composites" rendering technique. During compilation, the template (.aspx) file is compiled into initialization code that builds a control tree (the composite) representing the original template. Literal text goes into instances of the Literal control class, and server controls are represented by instances of a specific control class. The initialization code is combined with user-written code (usually by the assembly of multiple partial classes) and results in a class specific for the page. The page doubles as the root of the control tree.

Actual requests for the page are processed through a number of steps. First, during the initialization steps, an instance of the page class is created and the initialization code is executed. This produces the initial control tree, which is now typically manipulated by the methods of the page in the following steps. As each node in the tree is a control represented as an instance of a class, the code may change the tree structure as well as manipulate the properties/methods of the individual nodes. Finally, during the rendering step a visitor is used to visit every node in the tree, asking each node to render itself using the methods of the visitor. The resulting HTML output is sent to the client.

After the request has been processed, the instance of the page class is discarded and with it the entire control tree. This is a source of confusion among novice ASP.NET programmers who rely on the class instance members that are lost with every page request/response cycle.

ASP.NET applications are hosted by a Web server and are accessed using the stateless HTTP protocol. As such, if an application uses stateful interaction, it has to implement state management on its own. ASP.NET provides various functions for state management. Conceptually, Microsoft treats "state" as GUI state. Problems may arise if an application must track "data state"; for example, a finite-state machine that may be in a transient state between requests ( lazy evaluation ) or takes a long time to initialize. State management in ASP.NET pages with authentication can make Web scraping difficult or impossible.

Application state is held by a collection of shared user-defined variables. These are set and initialized when the Application_OnStart event fires on the loading of the first instance of the application and are available until the last instance exits. Application state variables are accessed using the Applications collection, which provides a wrapper for the application state. Application state variables are identified by name. Application is state management.

Server-side session state is held by a collection of user-defined session variables that are persistent during a user session. These variables, accessed using the Session collection, are unique to each session instance. The variables can be set to be automatically destroyed after a defined time of inactivity even if the session does not end. Client-side user session is maintained by either a cookie or by encoding the session ID in the URL itself.

ASP.NET supports three modes of persistence for server-side session variables:

ASP.NET session state enables you to store and retrieve values for a user as the user navigates ASP.NET pages in a Web application. HTTP is a stateless protocol. This means that a Web server treats each HTTP request for a page as an independent request. The server retains no knowledge of variable values that were used during previous requests. ASP.NET session state identifies requests from the same browser during a limited time window as a session, and provides a way to persist variable values for the duration of that session. By default, ASP.NET session state is enabled for all ASP.NET applications.

Alternatives to session state include the following:

View state refers to the page-level state management mechanism, utilized by the HTML pages emitted by ASP.NET applications to maintain the state of the Web form controls and widgets . The state of the controls is encoded and sent to the server at every form submission in a hidden field known as __VIEWSTATE . The server sends back the variable so that, when the page is re-rendered, the controls render at their last state. At the server side, the application may change the viewstate, if the processing requires a change of state of any control. The states of individual controls are decoded at the server, and are available for use in ASP.NET pages using the ViewState collection.

The main use for this is to preserve form information across postbacks. View state is turned on by default and normally serializes the data in every control on the page regardless of whether it is actually used during a postback. This behavior can (and should) be modified, however, as View state can be disabled on a per-control, per-page, or server-wide basis.

Developers need to be wary of storing sensitive or private information in the View state of a page or control, as the Base64 string containing the view state data can easily be de-serialized. By default, View state does not encrypt the __VIEWSTATE value. Encryption can be enabled on a server-wide (and server-specific) basis, allowing for a certain level of security to be maintained.

ASP.NET offers a "Cache" object that is shared across the application and can also be used to store various objects. The "Cache" object holds the data only for a specified amount of time.

Other means of state management that are supported by ASP.NET are cookies , caching , and the query string .

When first released, ASP.NET lacked a template engine . Because the .NET Framework is object-oriented and allows for inheritance , many developers would define a new base class that inherits from " System.Web.UI.Page ", write methods there that render HTML, and then make the pages in their application inherit from this new class. While this allows for common elements to be reused across a site, it adds complexity and mixes source code with markup . Furthermore, this method can only be visually tested by running the application – not while designing it. Other developers have used include files and other tricks to avoid having to implement the same navigation and other elements in every page.

ASP.NET 2.0 introduced the concept of master pages , which allow for template -based page development. A Web application can have one or more master pages, which, beginning with ASP.NET 2.0, can be nested. Master templates have place-holder controls, called ContentPlaceHolders to denote where the dynamic content goes, as well as HTML and JavaScript shared across child pages.

Child pages use those ContentPlaceHolder controls, which must be mapped to the place-holder of the master page that the content page is populating. The rest of the page is defined by the shared parts of the master page, much like a mail merge in a word processor . All markup and server controls in the content page must be placed within the ContentPlaceHolder control.

When a request is made for a content page, ASP.NET merges the output of the content page with the output of the master page, and sends the output to the user.

The master page remains fully accessible to the content page. This means that the content page may still manipulate headers, change title, configure caching, etc. If the master page exposes public properties or methods (e.g., for setting copyright notices) the content page can use these as well.

Other file extensions associated with different versions of ASP.NET include:

In general, the ASP.NET directory structure can be determined by the developer's preferences. Apart from a few reserved directory names, the site can span any number of directories. The structure is typically reflected directly in the URLs. Although ASP.NET provides means for intercepting the request at any point during processing, the developer is not forced to funnel requests through a central application or front controller.

The special directory names (from ASP.NET 2.0 on) are:

ASP.NET aims for performance benefits over other script-based technologies (including Classic ASP) by compiling the server-side code the first time it is used to one or more DLL files on the Web server . These dll files or assemblies contain Microsoft Intermediate Language (MSIL) for running within the common language runtime ; this provides a performance boost over pure scripted languages and is similar to the approach used by Python and not dissimilar to JavaServer Pages . This compilation happens automatically the first time a page is requested (which means the developer need not perform a separate compilation step for pages).

This feature provides the ease of development offered by scripting languages with the performance benefits of a compiled binary. However, the compilation might cause a noticeable but short delay to the user when the newly edited page is first requested from the Web server, but not again unless the requested page updates further.

The ASPX and other resource files are placed in a virtual host on an Internet Information Services server (or other compatible ASP.NET servers;  see Other implementations, below).  The first time a client requests a page, the .NET Framework parses and compiles the file(s) into a .NET assembly and sends the response;  subsequent requests are served from the DLL files. By default ASP.NET compiles the entire site in batches of 1000 files upon first request. If the compilation delay is causing problems, the batch size or the compilation strategy may be tweaked.

Developers can also choose to pre-compile their "codebehind" files before deployment, using Microsoft Visual Studio, eliminating the need for just-in-time compilation in a production environment. This also eliminates the need of having the source code on the Web server. It also supports pre-compile text.

ASP.NET WebForms simplifies developers' transition from Windows application development to Web development by offering the ability to build pages composed of controls similar to a Windows user interface . A Web control, such as a button or label , functions in very much the same way as its Windows counterparts: code can assign its properties and respond to its events. Controls know how to render themselves: whereas Windows controls draw themselves to the screen, web controls produce segments of HTML and JavaScript that form parts of the resulting page sent to the end-user's browser.

ASP.NET WebForms encourages the programmer to develop applications using an event-driven GUI model, rather than in conventional Web- scripting environments like ASP and PHP . The framework combines existing technologies such as JavaScript with internal components like " ViewState " to bring persistent (inter-request) state to the inherently stateless Web environment.

Other differences compared to Classic ASP are: