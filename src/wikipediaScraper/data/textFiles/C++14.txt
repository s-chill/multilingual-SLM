C++14 is a version of the ISO / IEC 14882 standard for the C++ programming language. It is intended to be a small extension over C++11 , featuring mainly bug fixes and small improvements, and was replaced by C++17 . Its approval was announced on August 18, 2014. C++14 was published as ISO/IEC 14882:2014 in December 2014.

Because earlier C++ standard revisions were noticeably late, the name "C++1y" was sometimes used instead until its approval, similarly to how the C++11 standard used to be termed "C++0x" with the expectation of its release before 2010 (although in fact it slipped into 2010 and finally 2011).

These are the features added to the core language of C++14.

C++11 allowed lambda functions to deduce the return type based on the type of the expression given to the return statement. C++14 provides this ability to all functions. It also extends these facilities to lambda functions, allowing return type deduction for functions that are not of the form return expression; .

In order to induce return type deduction, the function must be declared with auto as the return type, but without the trailing return type specifier in C++11:

If multiple return expressions are used in the function's implementation, then they must all deduce the same type.

Functions that deduce their return types can be forward declared, but they cannot be used until they have been defined. Their definitions must be available to the translation unit that uses them.

Recursion can be used with a function of this type, but the recursive call must happen after at least one return statement in the definition of the function:

In C++11, two methods of type deduction were added. auto was a way to create a variable of the appropriate type, based on a given expression. decltype was a way to compute the type of a given expression. However, decltype and auto deduce types in different ways. In particular, auto always deduces a non-reference type, as though by using std::decay , while auto&& always deduces a reference type. However, decltype can be prodded into deducing a reference or non-reference type, based on the value category of the expression and the nature of the expression it is deducing:

C++14 adds the decltype(auto) syntax. This allows auto declarations to use the decltype rules on the given expression.

The decltype(auto) syntax can also be used with return type deduction , by using decltype(auto) syntax instead of auto for the function's return type deduction.

C++11 introduced the concept of a constexpr-declared function; a function which could be executed at compile time. Their return values could be consumed by operations that require constant expressions, such as an integer template argument. However, C++11 constexpr functions could only contain a single expression that is returned (as well as static_assert s and a small number of other declarations).

C++14 relaxes these restrictions. Constexpr-declared functions may now contain the following:

goto statements are forbidden in C++14 relaxed constexpr-declared functions.

Also, C++11 stated that all non-static member functions that were declared constexpr were also implicitly declared const , with respect to this . That has since been removed; non-static member functions may be non- const . However, per the restrictions above, a non- const constexpr member function can only modify a class member if that object's lifetime began within the constant expression evaluation.

In prior versions of C++ , only functions, classes or type aliases could be templated. C++14 allows the creation of variables that are templated. An example given in the proposal is a variable pi that can be read to get the value of pi for various types (e.g., 3 when read as an integral type; the closest value possible with float , double or long double precision when read as float , double or long double , respectively; etc.).

The usual rules of templates apply to such declarations and definitions, including specialization.

C++11 added default member initializers, expressions to be applied to members at class scope if a constructor did not initialize the member itself. The definition of aggregates was changed to explicitly exclude any class with member initializers; therefore, they are not allowed to use aggregate initialization.

C++14 relaxes this restriction, allowing aggregate initialization on such types. If the braced init list does not provide a value for that argument, the member initializer takes care of it.

Numeric literals in C++14 can be specified in binary form . The syntax uses the prefixes 0b or 0B . The syntax is also used in other languages e.g. Java , C# , Swift , Go , Scala , Ruby , Python , OCaml , and as an unofficial extension in some C compilers since at least 2007.

In C++14, the single-quote character may be used arbitrarily as a digit separator in numeric literals, both integer literals and floating point literals. This can make it easier for human readers to parse large numbers through subitizing .

In C++11, lambda function parameters need to be declared with concrete types. C++14 relaxes this requirement, allowing lambda function parameters to be declared with the auto type specifier.

Concerning auto type deduction, generic lambdas follow the rules of template argument deduction (which are similar, but not identical in all respects ). The code above is equivalent to this:

Generic lambdas are essentially templated functor lambdas.

C++11 lambda functions capture variables declared in their outer scope by value-copy or by reference. This means that value members of a lambda cannot be move-only types. C++14 allows captured members to be initialized with arbitrary expressions. This allows both capture by value-move and declaring arbitrary members of the lambda, without having a correspondingly named variable in an outer scope.

This is done via the use of an initializer expression:

The lambda function lambda returns 1, which is what value was initialized with. The declared capture deduces the type from the initializer expression as if by auto .

This can be used to capture by move, via the use of the standard std::move function:

The deprecated attribute allows marking an entity deprecated , which makes it still legal to use but puts users on notice that use is discouraged and may cause a warning message to be printed during compilation. An optional string literal can appear as the argument of deprecated , to explain the rationale for deprecation and suggest a replacement.

C++14 adds a shared timed mutex and a companion shared lock type.

The C++ Standard Library defines four associative container classes. These classes allow the user to look up a value based on a value of that type. The map containers allow the user to specify a key and a value, where lookup is done by key and returns a value. However, the lookup is always done by the specific key type, whether it is the key as in maps or the value itself as in sets.

C++14 allows the lookup to be done via an arbitrary type, so long as the comparison operator can compare that type with the actual key type. This would allow a map from std::string to some value to compare against a const char* or any other type for which an operator< overload is available. It is also useful for indexing composite objects in a std::set by the value of a single member without forcing the user of find to create a dummy object (for example creating an entire struct Person to find a person by name).

To preserve backwards compatibility, heterogeneous lookup is only allowed when the comparator given to the associative container allows it. The standard library classes std::less<> and std::greater<> are augmented to allow heterogeneous lookup.

C++11 defined the syntax for user-defined literal suffixes, but the standard library did not use any of them. C++14 adds the following standard literals:

The two "s" literals do not clash, as the string one only operates on string literals , and the one for seconds operates only on numbers.

The std::tuple type introduced in C++11 allows an aggregate of typed values to be indexed by a compile-time constant integer. C++14 extends this to allow fetching from a tuple by type instead of by index. If the tuple has more than one element of the type, a compile-time error results:

std::make_unique can be used like std::make_shared for std::unique_ptr objects.

std::integral_constant gained an operator() overload to return the constant value.

The class template std::integer_sequence and related alias templates were added for representing compile-time integer sequences, such as the indices of elements in a parameter pack.

The global std::begin / std::end functions were augmented with std::cbegin / std::cend functions, which return constant iterators, and std::rbegin / std::rend and std::crbegin / std::crend which return reverse iterators.

The std::exchange function template assigns a new value to a variable and returns the old value.

New overloads of std::equal , std::mismatch , and std::is_permutation take a pair of iterators for the second range, so that the caller does not need to separately check that the two ranges are of the same length.

The std::is_final type trait detects if a class is marked final .

The std::quoted stream I/O manipulator allows inserting and extracting strings with embedded spaces, by placing delimiters (defaulting to double-quotes) on output and stripping them on input, and escaping any embedded delimiters.

Clang finished support for C++14 in 3.4 though under the standard name c++1y, and made C++14 the default C++ standard in Clang 6. GCC finished support for C++14 in GCC 5, and made C++14 the default C++ standard in GCC 6. Microsoft Visual Studio 2017 has implemented "almost all" C++14 features.