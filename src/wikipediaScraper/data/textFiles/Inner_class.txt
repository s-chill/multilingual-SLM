In object-oriented programming (OOP), an inner class or nested class is a class declared entirely within the body of another class or interface. It is distinguished from a subclass .

An instance of a normal or top-level class can exist on its own. By contrast, an instance of an inner class cannot be instantiated without being bound to a top-level class.

Let us take the abstract notion of a Car with four Wheel s. Our Wheel s have a specific feature that relies on being part of our Car . This notion does not represent the Wheel s as Wheel s in a more general form that could be part of any vehicle. Instead, it represents them as specific to a Car . We can model this notion using inner classes as follows:

We have the top-level class Car . Instances of class Car are composed of four instances of the class Wheel . This particular implementation of Wheel is specific to a car, so the code does not model the general notion of a wheel that would be better represented as a top-level class. Therefore, it is semantically connected to the class Car and the code of Wheel is in some way coupled to its outer class, being a composition unit of a car. The wheel for a particular car is unique to that car, but for generalization, the wheel is an aggregation unit to the car.

Inner classes provide a mechanism to accurately model this connection. We can refer to our Wheel class as Car.Wheel , Car being the top-level class and Wheel being the inner class.

Inner classes therefore allow for the object orientation of certain parts of the program that would otherwise not be encapsulated into a class.

Larger segments of code within a class might be better modeled or refactored as a separate top-level class, rather than an inner class. This would make the code more general in its application and therefore more re-usable but potentially might be premature generalization. This may prove more effective, if code has many inner classes with the shared functionality.

In Java there are four types of nested class:

Inner class –  The following categories are called inner classes . Each instance of these classes has a reference to an enclosing instance (i.e. an instance of the enclosing class), except for local and anonymous classes declared in static context. Hence, they can implicitly refer to instance variables and methods of the enclosing class. The enclosing instance reference can be explicitly obtained via EnclosingClassName.this . Inner classes may not have static variables or methods, except for compile-time constant variables. When they are created, they must have a reference to an instance of the enclosing class; which means they must either be created within an instance method or constructor of the enclosing class, or (for member and anonymous classes) be created using the syntax enclosingInstance.new InnerClass() .

Local inner classes are often used in Java to define callbacks for GUI code. Components can then share an object that implements an event handling interface or extends an abstract adapter class, containing the code to be executed when a given event is triggered.

Anonymous inner classes are also used where the event handling code is only used by one component and therefore does not need a named reference.

This avoids a large monolithic actionPerformed(ActionEvent) method with multiple if-else branches to identify the source of the event. This type of code is often considered messy and the inner class variations are considered to be better in all regards.