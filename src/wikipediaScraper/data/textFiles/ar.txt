The archiver , also known simply as ar , is a Unix utility that maintains groups of files as a single archive file . Today, ar is generally used only to create and update static library files that the link editor or linker uses and for generating .deb packages for the Debian family; it can be used to create archives for any purpose, but has been largely replaced by tar for purposes other than static libraries. An implementation of ar is included as one of the GNU Binutils .

In the Linux Standard Base (LSB), ar has been deprecated and is expected to disappear in a future release of that standard. The rationale provided was that "the LSB does not include software development utilities nor does it specify .o and .a file formats."

The ar format has never been standardized; modern archives are based on a common format with two main variants, BSD and System V (initially known as COFF , and used as well by GNU , ELF , and Windows .)

Historically there have been other variants including V6 , V7 , AIX (small and big), and Coherent, which all vary significantly from the common format.

Debian ". deb " archives use the common format.

An ar file begins with a global header , followed by a header and data section for each file stored within the ar file.

Each data section is 2 byte aligned. If it would end on an odd offset, a newline ('\n', 0x0A) is used as filler.

The file signature is a single field containing the magic ASCII string "!<arch>" followed by a single LF control character (0x0A).

Each file stored in an ar archive includes a file header to store information about the file. The common format is as follows. Numeric values are encoded in ASCII and all values right-padded with ASCII spaces (0x20).

As the headers only include printable ASCII characters and line feeds, an archive containing only text files therefore still appears to be a text file itself.

The members are aligned to even byte boundaries.  "Each  archive file member begins on an even byte boundary; a newline is inserted between files  if  necessary.  Nevertheless,  the  size  given reflects the actual size of the file exclusive of padding."

Due to the limitations of file name length and format, both the GNU and BSD variants devised different methods of storing long filenames. Although the common format does not suffer from the year 2038 problem , many implementations of the ar utility do and may need to be modified in the future to handle correctly timestamps in excess of 2147483647. A description of these extensions is found in libbfd.

Depending on the format, many ar implementations include a global symbol table (aka armap, directory or index) for fast linking without needing to scan the whole archive for a symbol. POSIX recognizes this feature, and requires ar implementations to have an -s option for updating it. Most implementations put it at the first file entry.

BSD ar stores filenames right-padded with ASCII spaces. This causes issues with spaces inside filenames. 4.4BSD ar stores extended filenames by placing the string "#1/" followed by the file name length in the file name field, and storing the real filename in front of the data section.

BSD ar utility traditionally does not handle the building of a global symbol lookup table, and delegates this task to a separate utility named ranlib , which inserts an architecture-specific file named __.SYMDEF as first archive member. Some descendents put a space and "SORTED" after the name to indicate a sorted version. A 64-bit variant called __.SYMDEF_64 exists on Darwin .

Since POSIX added the requirement for the -s option as an replacement of ranlib, however, newer BSD ar implementations have been rewritten to have this feature. FreeBSD in particular ditched the SYMDEF table format and embraced the System V style table.

System V ar uses a '/' character (0x2F) to mark the end of the filename; this allows for the use of spaces without the use of an extended filename.  Then it stores multiple extended filenames in the data section of a file with the name "//", this record is referred to by future headers. A header references an extended filename by storing a "/" followed by a decimal offset to the start of the filename in the extended filename data section.  The format of this "//" file itself is simply a list of the long filenames, each separated by one or more LF characters.  Note that the decimal offsets are number of characters, not line or string number within the "//" file. This is usually the second entry of the file, after the symbol table which always is the first.

System V ar uses the special filename "/" to denote that the following data entry contains a symbol lookup table, which is used in ar libraries to speed up access.  This symbol table is built in three parts which are recorded together as contiguous data.

Some System V systems do not use the format described above for the symbol lookup table.
For operating systems such as HP-UX 11.0, this information is stored in a data structure based on the SOM file format.

The special file "/" is not terminated with a specific sequence; the end is assumed once the last symbol name has been read.

To overcome the 4 GiB file size limit some operating system like Solaris 11.2 and GNU use a variant lookup table. Instead of 32-bit integers, 64-bit integers are used in the symbol lookup tables. The string "/SYM64/" instead "/" is used as identifier for this table

The Windows (PE/COFF) variant is based on the SysV/GNU variant. The first entry "/" has the same layout as the SysV/GNU symbol table. The second entry is another "/", a Microsoft extension that stores an extended symbol cross-reference table. This one is sorted and uses little-endian integers. The third entry is the optional "//" long name data as in SysV/GNU.

The version of ar in GNU binutils and Elfutils have an additional "thin archive" format with the magic number !<thin> . A thin archive only contains a symbol table and references to the file. The file format is essentially a System V format archive where every file is stored without the data sections. Every filename is stored as a "long" filename and they are to be resolved as if they were symbolic links .

To create an archive from files class1.o , class2.o , class3.o , the following command would be used:

Unix linkers, usually invoked through the C compiler cc , can read ar files and extract object files from them, so if libclass.a is an archive containing class1.o , class2.o and class3.o , then

or (if libclass.a is placed in standard library path, like /usr/local/lib )

or (during linking)

is the same as: