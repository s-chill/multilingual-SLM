In logic and proof theory , natural deduction is a kind of proof calculus in which logical reasoning is expressed by inference rules closely related to the "natural" way of reasoning. This contrasts with Hilbert-style systems , which instead use axioms as much as possible to express the logical laws of deductive reasoning .

Natural deduction grew out of a context of dissatisfaction with the axiomatizations of deductive reasoning common to the systems of Hilbert , Frege , and Russell (see, e.g., Hilbert system ). Such axiomatizations were most famously used by Russell and Whitehead in their mathematical treatise Principia Mathematica . Spurred on by a series of seminars in Poland in 1926 by Łukasiewicz that advocated a more natural treatment of logic, Jaśkowski made the earliest attempts at defining a more natural deduction, first in 1929 using a diagrammatic notation, and later updating his proposal in a sequence of papers in 1934 and 1935. His proposals led to different notations
such as Fitch-style calculus (or Fitch's diagrams) or Suppes ' method for which Lemmon gave a variant now known as Suppes–Lemmon notation .

Natural deduction in its modern form was independently proposed by the German mathematician Gerhard Gentzen in 1933, in a dissertation delivered to the faculty of mathematical sciences of the University of Göttingen . The term natural deduction (or rather, its German equivalent natürliches Schließen ) was coined in that paper:

Gentzen was motivated by a desire to establish the consistency of number theory . He was unable to prove the main result required for the consistency result, the cut elimination theorem —the Hauptsatz—directly for natural deduction. For this reason he introduced his alternative system, the sequent calculus , for which he proved the Hauptsatz both for classical and intuitionistic logic . In a series of seminars in 1961 and 1962 Prawitz gave a comprehensive summary of natural deduction calculi, and transported much of Gentzen's work with sequent calculi into the natural deduction framework. His 1965 monograph Natural deduction: a proof-theoretical study was to become a reference work on natural deduction, and included applications for modal and second-order logic .

In natural deduction, a proposition is deduced from a collection of premises by applying inference rules repeatedly. The system presented in this article is a minor variation of Gentzen's or Prawitz's formulation, but with a closer adherence to Martin-Löf 's description of logical judgments and connectives.

Natural deduction has had a large variety of notation styles, which can make it difficult to recognize a proof if you're not familiar with one of them. To help with this situation, this article has a § Notation section explaining how to read all the notation that it will actually use. This section just explains the historical evolution of notation styles, most of which cannot be shown because there are no illustrations available under a public copyright license – the reader is pointed to the SEP and IEP for pictures.

Here is a table with the most common notational variants for logical connectives .

Gentzen , who invented natural deduction, had his own notation style for arguments. This will be exemplified by a simple argument below. Let's say we have a simple example argument in propositional logic , such as, "if it's raining then it's cloudly; it is raining; therefore it's cloudy". (This is in modus ponens .) Representing this as a list of propositions, as is common, we would have:

In Gentzen's notation, this would be written like this:

The premises are shown above a line, called the inference line , separated by a comma , which indicates combination of premises. The conclusion is written below the inference line. The inference line represents syntactic consequence , sometimes called deductive consequence , which is also symbolized with ⊢. So the above can also be written in one line as P → Q , P ⊢ Q {\displaystyle P\to Q,P\vdash Q} . (The turnstile, for syntactic consequence, is of lower precedence than the comma, which represents premise combination, which in turn is of lower precedence than the arrow, used for material implication; so no parentheses are needed to interpret this formula.)

Syntactic consequence is contrasted with semantic consequence , which is symbolized with ⊧. In this case, the conclusion follows syntactically because natural deduction is a syntactic proof system , which assumes inference rules as primitives .

Gentzen's style will be used in much of this article. Gentzen's discharging annotations used to internalise hypothetical judgments can be avoided by representing proofs as a tree of sequents Γ ⊢A instead of a tree of judgments that A (is true).

Many textbooks use Suppes–Lemmon notation , so this article will also give that – although as of now, this is only included for propositional logic , and the rest of the coverage is given only in Gentzen style. A proof , laid out in accordance with the Suppes–Lemmon notation style, is a sequence of lines containing sentences, where each sentence is either an assumption, or the result of applying a rule of proof to earlier sentences in the sequence. Each line of proof is made up of a sentence of proof , together with its annotation , its assumption set , and the current line number . The assumption set lists the assumptions on which the given sentence of proof depends, which are referenced by the line numbers. The annotation specifies which rule of proof was applied, and to which earlier lines, to yield the current sentence. Here's an example proof:

This proof will become clearer when the inference rules and their appropriate annotations are specified – see § Propositional inference rules (Suppes–Lemmon style) .

This section defines the formal syntax for a propositional logic language , contrasting the common ways of doing so with a Gentzen-style way of doing so.

The formal language L {\displaystyle {\mathcal {L}}} of a propositional calculus is usually defined by a recursive definition , such as this one, from Bostock :

There are other ways of doing it, such as the BNF grammar ϕ ::= a 1 , a 2 , … | ¬ ϕ | ϕ ∧ ψ | ϕ ∨ ψ | ϕ → ψ | ϕ ↔ ψ {\displaystyle \phi ::=a_{1},a_{2},\ldots ~|~\neg \phi ~|~\phi ~\land ~\psi ~|~\phi \vee \psi ~|~\phi \rightarrow \psi ~|~\phi \leftrightarrow \psi } .

A syntax definition can also be given using § Gentzen's tree notation , by writing well-formed formulas below the inference line and any schematic variables used by those formulas above it. For instance, the equivalent of rules 3 and 4, from Bostock's definition above, is written as follows:

A different notational convention sees the language's syntax as a categorial grammar with the single category "formula", denoted by the symbol F {\displaystyle {\mathcal {F}}} . So any elements of the syntax are introduced by categorizations, for which the notation is φ : F {\displaystyle \varphi :{\mathcal {F}}} , meaning " φ {\displaystyle \varphi } is an expression for an object in the category F {\displaystyle {\mathcal {F}}} ." The sentence-letters, then, are introduced by categorizations such as P : F {\displaystyle P:{\mathcal {F}}} , Q : F {\displaystyle Q:{\mathcal {F}}} , R : F {\displaystyle R:{\mathcal {F}}} , and so on; the connectives, in turn, are defined by statements similar to the above, but using categorization notation, as seen below:

In the rest of this article, the φ : F {\displaystyle \varphi :{\mathcal {F}}} categorization notation will be used for any Gentzen-notation statements defining the language's grammar; any other statements in Gentzen notation will be inferences, asserting that a sequent follows rather than that an expression is a well-formed formula.

The following is a complete list of primitive inference rules for natural deduction in classical propositional logic:

This table follows the custom of using Greek letters as schemata , which may range over any formulas, rather than only over atomic propositions. The name of a rule is given to the right of its formula tree. For instance, the first introduction rule is named ∧ i {\displaystyle \wedge _{i}} , which is short for "conjunction introduction".

As an example of the use of inference rules, consider commutativity of conjunction. If A ∧ B , then B ∧ A ; this derivation can be drawn by composing inference rules in such a fashion that premises of a lower inference match the conclusion of the next higher inference.

A ∧ B B ∧ E 2 A ∧ B A ∧ E 1 B ∧ A ∧ I {\displaystyle {\cfrac {{\cfrac {A\wedge B}{B{\hbox{ }}}}\ \wedge _{E2}\qquad {\cfrac {A\wedge B}{A}}\ \wedge _{E1}}{B\wedge A}}\ \wedge _{I}}

As a second example, consider the derivation of " A ⊃ (B ⊃ (A ∧ B)) ":

A u B w A ∧ B ∧ I B ⊃ ( A ∧ B ) A ⊃ ( B ⊃ ( A ∧ B ) ) ⊃ I u ⊃ I w {\displaystyle {\cfrac {{\cfrac {{\cfrac {}{A}}\ u\quad {\cfrac {}{B}}\ w}{A\wedge B}}\ \wedge _{I}}{{\cfrac {B\supset \left(A\wedge B\right)}{A\supset \left(B\supset \left(A\wedge B\right)\right)}}\ \supset _{I^{u}}}}\ \supset _{I^{w}}}

This full derivation has no unsatisfied premises; however, sub-derivations are hypothetical. For instance, the derivation of " B ⊃ (A ∧ B) " is hypothetical with antecedent " A " (named u ).

Natural deduction inference rules, due ultimately to Gentzen , are given below. There are ten primitive rules of proof, which are the rule assumption , plus four pairs of introduction and elimination rules for the binary connectives, and the rule reductio ad adbsurdum . Disjunctive Syllogism can be used as an easier alternative to the proper ∨-elimination, and MTT and DN are commonly given rules, although they are not primitive.

Recall that an example proof was already given when introducing § Suppes–Lemmon notation . This is a second example.

A theory is said to be consistent if falsehood is not provable (from no assumptions) and is complete if every theorem or its negation is provable using the inference rules of the logic. These are statements about the entire logic, and are usually tied to some notion of a model . However, there are local notions of consistency and completeness that are purely syntactic checks on the inference rules, and require no appeals to models. The first of these is local consistency, also known as local reducibility, which says that any derivation containing an introduction of a connective followed immediately by its elimination can be turned into an equivalent derivation without this detour. It is a check on the strength of elimination rules: they must not be so strong that they include knowledge not already contained in their premises. As an example, consider conjunctions.

Dually, local completeness says that the elimination rules are strong enough to decompose a connective into the forms suitable for its introduction rule. Again for conjunctions:

These notions correspond exactly to β-reduction (beta reduction) and η-conversion (eta conversion) in the lambda calculus , using the Curry–Howard isomorphism . By local completeness, we see that every derivation can be converted to an equivalent derivation where the principal connective is introduced. In fact, if the entire derivation obeys this ordering of eliminations followed by introductions, then it is said to be normal . In a normal derivation all eliminations happen above introductions. In most logics, every derivation has an equivalent normal derivation, called a normal form . The existence of normal forms is generally hard to prove using natural deduction alone, though such accounts do exist in the literature, most notably by Dag Prawitz in 1961. It is much easier to show this indirectly by means of a cut-free sequent calculus presentation.

The logic of the earlier section is an example of a single-sorted logic, i.e. , a logic with a single kind of object: propositions. Many extensions of this simple framework have been proposed; in this section we will extend it with a second sort of individuals or terms . More precisely, we will add a new category, "term", denoted T {\displaystyle {\mathcal {T}}} . We shall fix a countable set V {\displaystyle V} of variables , another countable set F {\displaystyle F} of function symbols , and construct terms with the following formation rules:

and

For propositions, we consider a third countable set P of predicates , and define atomic predicates over terms with the following formation rule:

The first two rules of formation provide a definition of a term that is effectively the same as that defined in term algebra and model theory , although the focus of those fields of study is quite different from natural deduction. The third rule of formation effectively defines an atomic formula , as in first-order logic , and again in model theory.

To these are added a pair of formation rules, defining the notation for quantified propositions; one for universal (∀) and existential (∃) quantification:

The universal quantifier has the introduction and elimination rules:

The existential quantifier has the introduction and elimination rules:

In these rules, the notation [ t / x ] A stands for the substitution of t for every (visible) instance of x in A , avoiding capture. As before the superscripts on the name stand for the components that are discharged: the term a cannot occur in the conclusion of ∀I (such terms are known as eigenvariables or parameters ), and the hypotheses named u and v in ∃E are localised to the second premise in a hypothetical derivation. Although the propositional logic of earlier sections was decidable , adding the quantifiers makes the logic undecidable.

So far, the quantified extensions are first-order : they distinguish propositions from the kinds of objects quantified over. Higher-order logic takes a different approach and has only a single sort of propositions. The quantifiers have as the domain of quantification the very same sort of propositions, as reflected in the formation rules:

A discussion of the introduction and elimination forms for higher-order logic is beyond the scope of this article. It is possible to be in-between first-order and higher-order logics. For example, second-order logic has two kinds of propositions, one kind quantifying over terms, and the second kind quantifying over propositions of the first kind.

The presentation of natural deduction so far has concentrated on the nature of propositions without giving a formal definition of a proof . To formalise the notion of proof, we alter the presentation of hypothetical derivations slightly. We label the antecedents with proof variables (from some countable set V of variables), and decorate the succedent with the actual proof. The antecedents or hypotheses are separated from the succedent by means of a turnstile (⊢). This modification sometimes goes under the name of localised hypotheses . The following diagram summarises the change.

The collection of hypotheses will be written as Γ when their exact composition is not relevant.
To make proofs explicit, we move from the proof-less judgment " A " to a judgment: "π is a proof of (A) ", which is written symbolically as "π : A ". Following the standard approach, proofs are specified with their own formation rules for the judgment "π proof ". The simplest possible proof is the use of a labelled hypothesis; in this case the evidence is the label itself.

Let us re-examine some of the connectives with explicit proofs. For conjunction, we look at the introduction rule ∧I to discover the form of proofs of conjunction: they must be a pair of proofs of the two conjuncts. Thus:

The elimination rules ∧E 1 and ∧E 2 select either the left or the right conjunct; thus the proofs are a pair of projections—first ( fst ) and second ( snd ).

For implication, the introduction form localises or binds the hypothesis, written using a λ; this corresponds to the discharged label. In the rule, "Γ, u : A " stands for the collection of hypotheses Γ, together with the additional hypothesis u .

With proofs available explicitly, one can manipulate and reason about proofs. The key operation on proofs is the substitution of one proof for an assumption used in another proof. This is commonly known as a substitution theorem , and can be proved by induction on the depth (or structure) of the second judgment.

So far the judgment "Γ ⊢ π : A " has had a purely logical interpretation. In type theory , the logical view is exchanged for a more computational view of objects. Propositions in the logical interpretation are now viewed as types , and proofs as programs in the lambda calculus . Thus the interpretation of "π : A " is " the program π has type A ". The logical connectives are also given a different reading: conjunction is viewed as product (×), implication as the function arrow (→), etc. The differences are only cosmetic, however. Type theory has a natural deduction presentation in terms of formation, introduction and elimination rules; in fact, the reader can easily reconstruct what is known as simple type theory from the previous sections.

The difference between logic and type theory is primarily a shift of focus from the types (propositions) to the programs (proofs). Type theory is chiefly interested in the convertibility or reducibility of programs. For every type, there are canonical programs of that type which are irreducible; these are known as canonical forms or values . If every program can be reduced to a canonical form, then the type theory is said to be normalising (or weakly normalising ). If the canonical form is unique, then the theory is said to be strongly normalising . Normalisability is a rare feature of most non-trivial type theories, which is a big departure from the logical world. (Recall that almost every logical derivation has an equivalent normal derivation.) To sketch the reason: in type theories that admit recursive definitions, it is possible to write programs that never reduce to a value; such looping programs can generally be given any type. In particular, the looping program has type ⊥, although there is no logical proof of "⊥". For this reason, the propositions as types; proofs as programs paradigm only works in one direction, if at all: interpreting a type theory as a logic generally gives an inconsistent logic.

Like logic, type theory has many extensions and variants, including first-order and higher-order versions. One branch, known as dependent type theory , is used in a number of computer-assisted proof systems.  Dependent type theory allows quantifiers to range over programs themselves. These quantified types are written as Π and Σ instead of ∀ and ∃, and have the following formation rules:

These types are generalisations of the arrow and product types, respectively, as witnessed by their introduction and elimination rules.

Dependent type theory in full generality is very powerful: it is able to express almost any conceivable property of programs directly in the types of the program. This generality comes at a steep price — either typechecking is undecidable ( extensional type theory ), or extensional reasoning is more difficult ( intensional type theory ). For this reason, some dependent type theories do not allow quantification over arbitrary programs, but rather restrict to programs of a given decidable index domain , for example integers, strings, or linear programs.

Since dependent type theories allow types to depend on programs, a natural question to ask is whether it is possible for programs to depend on types, or any other combination. There are many kinds of answers to such questions. A popular approach in type theory is to allow programs to be quantified over types, also known as parametric polymorphism ; of this there are two main kinds: if types and programs are kept separate, then one obtains a somewhat more well-behaved system called predicative polymorphism ; if the distinction between program and type is blurred, one obtains the type-theoretic analogue of higher-order logic, also known as impredicative polymorphism . Various combinations of dependency and polymorphism have been considered in the literature, the most famous being the lambda cube of Henk Barendregt .

The intersection of logic and type theory is a vast and active research area. New logics are usually formalised in a general type theoretic setting, known as a logical framework . Popular modern logical frameworks such as the calculus of constructions and LF are based on higher-order dependent type theory, with various trade-offs in terms of decidability and expressive power. These logical frameworks are themselves always specified as natural deduction systems, which is a testament to the versatility of the natural deduction approach.

For simplicity, the logics presented so far have been intuitionistic . Classical logic extends intuitionistic logic with an additional axiom or principle of excluded middle :

This statement is not obviously either an introduction or an elimination; indeed, it involves two distinct connectives. Gentzen's original treatment of excluded middle prescribed one of the following three (equivalent) formulations, which were already present in analogous forms in the systems of Hilbert and Heyting :

(XM 3 is merely XM 2 expressed in terms of E.) This treatment of excluded middle, in addition to being objectionable from a purist's standpoint, introduces additional complications in the definition of normal forms.

A comparatively more satisfactory treatment of classical natural deduction in terms of introduction and elimination rules alone was first proposed by Parigot in 1992 in the form of a classical lambda calculus called λμ . The key insight of his approach was to replace a truth-centric judgment A with a more classical notion, reminiscent of the sequent calculus : in localised form, instead of Γ ⊢ A , he used Γ ⊢ Δ, with Δ a collection of propositions similar to Γ. Γ was treated as a conjunction, and Δ as a disjunction. This structure is essentially lifted directly from classical sequent calculi , but the innovation in λμ was to give a computational meaning to classical natural deduction proofs in terms of a callcc or a throw/catch mechanism seen in LISP and its descendants. (See also: first class control .)

Another important extension was for modal and other logics that need more than just the basic judgment of truth. These were first described, for the alethic modal logics S4 and S5 , in a natural deduction style by Prawitz in 1965, and have since accumulated a large body of related work. To give a simple example, the modal logic S4 requires one new judgment, " A valid ", that is categorical with respect to truth:

This categorical judgment is internalised as a unary connective ◻ A (read " necessarily A ") with the following introduction and elimination rules:

Note that the premise " A valid " has no defining rules; instead, the categorical definition of validity is used in its place. This mode becomes clearer in the localised form when the hypotheses are explicit. We write "Ω;Γ ⊢ A " where Γ contains the true hypotheses as before, and Ω contains valid hypotheses. On the right there is just a single judgment " A "; validity is not needed here since "Ω ⊢ A valid " is by definition the same as "Ω;⋅ ⊢ A ". The introduction and elimination forms are then:

The modal hypotheses have their own version of the hypothesis rule and substitution theorem.

This framework of separating judgments into distinct collections of hypotheses, also known as multi-zoned or polyadic contexts, is very powerful and extensible; it has been applied for many different modal logics, and also for linear and other substructural logics , to give a few examples.  However, relatively few systems of modal logic can be formalised directly in natural deduction. To give proof-theoretic characterisations of these systems, extensions such as labelling or systems of deep inference.

The addition of labels to formulae permits much finer control of the conditions under which rules apply, allowing the more flexible techniques of analytic tableaux to be applied, as has been done in the case of labelled deduction .  Labels also allow the naming of worlds in Kripke semantics; Simpson (1993) presents an influential technique for converting frame conditions of modal logics in Kripke semantics into inference rules in a natural deduction formalisation of hybrid logic . Stouppa (2004) surveys the application of many proof theories, such as Avron and Pottinger's hypersequents and Belnap's display logic to such modal logics as S5 and B.

The sequent calculus is the chief alternative to natural deduction as a foundation of mathematical logic . In natural deduction the flow of information is bi-directional: elimination rules flow information downwards by deconstruction, and introduction rules flow information upwards by assembly. Thus, a natural deduction proof does not have a purely bottom-up or top-down reading, making it unsuitable for automation in proof search. To address this fact, Gentzen in 1935 proposed his sequent calculus , though he initially intended it as a technical device for clarifying the consistency of predicate logic . Kleene , in his seminal 1952 book Introduction to Metamathematics , gave the first formulation of the sequent calculus in the modern style.

In the sequent calculus all inference rules have a purely bottom-up reading. Inference rules can apply to elements on both sides of the turnstile . (To differentiate from natural deduction, this article uses a double arrow ⇒ instead of the right tack ⊢ for sequents.) The introduction rules of natural deduction are viewed as right rules in the sequent calculus, and are structurally very similar. The elimination rules on the other hand turn into left rules in the sequent calculus. To give an example, consider disjunction; the right rules are familiar:

On the left:

Recall the ∨E rule of natural deduction in localised form:

The proposition A ∨ B , which is the succedent of a premise in ∨E, turns into a hypothesis of the conclusion in the left rule ∨L. Thus, left rules can be seen as a sort of inverted elimination rule. This observation can be illustrated as follows:

In the sequent calculus, the left and right rules are performed in lock-step until one reaches the initial sequent , which corresponds to the meeting point of elimination and introduction rules in natural deduction. These initial rules are superficially similar to the hypothesis rule of natural deduction, but in the sequent calculus they describe a transposition or a handshake of a left and a right proposition:

The correspondence between the sequent calculus and natural deduction is a pair of soundness and completeness theorems, which are both provable by means of an inductive argument.

It is clear by these theorems that the sequent calculus does not change the notion of truth, because the same collection of propositions remain true. Thus, one can use the same proof objects as before in sequent calculus derivations. As an example, consider the conjunctions. The right rule is virtually identical to the introduction rule

The left rule, however, performs some additional substitutions that are not performed in the corresponding elimination rules.

The kinds of proofs generated in the sequent calculus are therefore rather different from those of natural deduction. The sequent calculus produces proofs in what is known as the β-normal η-long form, which corresponds to a canonical representation of the normal form of the natural deduction proof. If one attempts to describe these proofs using natural deduction itself, one obtains what is called the intercalation calculus (first described by John Byrnes), which can be used to formally define the notion of a normal form for natural deduction.

The substitution theorem of natural deduction takes the form of a structural rule or structural theorem known as cut in the sequent calculus.

In most well behaved logics, cut is unnecessary as an inference rule, though it remains provable as a meta-theorem ; the superfluousness of the cut rule is usually presented as a computational process, known as cut elimination . This has an interesting application for natural deduction; usually it is extremely tedious to prove certain properties directly in natural deduction because of an unbounded number of cases. For example, consider showing that a given proposition is not provable in natural deduction. A simple inductive argument fails because of rules like ∨E or E which can introduce arbitrary propositions. However, we know that the sequent calculus is complete with respect to natural deduction, so it is enough to show this unprovability in the sequent calculus. Now, if cut is not available as an inference rule, then all sequent rules either introduce a connective on the right or the left, so the depth of a sequent derivation is fully bounded by the connectives in the final conclusion. Thus, showing unprovability is much easier, because there are only a finite number of cases to consider, and each case is composed entirely of sub-propositions of the conclusion. A simple instance of this is the global consistency theorem: "⋅ ⊢ ⊥" is not provable. In the sequent calculus version, this is manifestly true because there is no rule that can have "⋅ ⇒ ⊥" as a conclusion! Proof theorists often prefer to work on cut-free sequent calculus formulations because of such properties.