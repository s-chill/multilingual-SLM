In computer science and logic , a dependent type is a type whose definition depends on a value. It is an overlapping feature of type theory and type systems . In intuitionistic type theory , dependent types are used to encode logic's quantifiers like "for all" and "there exists". In functional programming languages like Agda , ATS , Coq , F* , Epigram , Idris , and Lean , dependent types help reduce bugs by enabling the programmer to assign types that further restrain the set of possible implementations.

Two common examples of dependent types are dependent functions and dependent pairs . The return type of a dependent function may depend on the value (not just type) of one of its arguments. For instance, a function that takes a positive integer n {\displaystyle n} may return an array of length n {\displaystyle n} , where the array length is part of the type of the array. (Note that this is different from polymorphism and generic programming , both of which include the type as an argument.) A dependent pair may have a second value, the type of which depends on the first value. Sticking with the array example, a dependent pair may be used to pair an array with its length in a type-safe way.

Dependent types add complexity to a type system. Deciding the equality of dependent types in a program may require computations. If arbitrary values are allowed in dependent types, then deciding type equality may involve deciding whether two arbitrary programs produce the same result; hence the decidability of type checking may depend on the given type theory's semantics of equality, that is, whether the type theory is intensional or extensional .

In 1934, Haskell Curry noticed that the types used in typed lambda calculus , and in its combinatory logic counterpart, followed the same pattern as axioms in propositional logic . Going further, for every proof in the logic, there was a matching function (term) in the programming language. One of Curry's examples was the correspondence between simply typed lambda calculus and intuitionistic logic .

Predicate logic is an extension of propositional logic, adding quantifiers. Howard and de Bruijn extended lambda calculus to match this more powerful logic by creating types for dependent functions, which correspond to "for all", and dependent pairs, which correspond to "there exists".

(Because of this and other work by Howard, propositions-as-types is known as the Curry–Howard correspondence .)

Loosely speaking, dependent types are similar to the type of an indexed family of sets. More formally, given a type A : U {\displaystyle A:{\mathcal {U}}} in a universe of types U {\displaystyle {\mathcal {U}}} , one may have a family of types B : A → U {\displaystyle B:A\to {\mathcal {U}}} , which assigns to each term a : A {\displaystyle a:A} a type B ( a ) : U {\displaystyle B(a):{\mathcal {U}}} . We say that the type B ( a ) {\displaystyle B(a)} varies with a {\displaystyle a} .

A function whose type of return value varies with its argument (i.e. there is no fixed codomain ) is a dependent function and the type of this function is called dependent product type , pi-type ( Π type ) or dependent function type . From a family of types B : A → U {\displaystyle B:A\to {\mathcal {U}}} we may construct the type of dependent functions ∏ x : A B ( x ) {\textstyle \prod _{x:A}B(x)} , whose terms are functions that take a term a : A {\displaystyle a:A} and return a term in B ( a ) {\displaystyle B(a)} . For this example, the dependent function type is typically written as ∏ x : A B ( x ) {\textstyle \prod _{x:A}B(x)} or ∏ ( x : A ) B ( x ) {\textstyle \prod {(x:A)}B(x)} .

If B : A → U {\displaystyle B:A\to {\mathcal {U}}} is a constant function, the corresponding dependent product type is equivalent to an ordinary function type . That is, ∏ x : A B {\textstyle \prod _{x:A}B} is judgmentally equal to A → B {\displaystyle A\to B} when B {\displaystyle B} does not depend on x {\displaystyle x} .

The name 'Π-type' comes from the idea that these may be viewed as a Cartesian product of types. Π-types can also be understood as models of universal quantifiers .

For example, if we write Vec ⁡ ( R , n ) {\displaystyle \operatorname {Vec} (\mathbb {R} ,n)} for n -tuples of real numbers , then ∏ n : N Vec ⁡ ( R , n ) {\textstyle \prod _{n:\mathbb {N} }\operatorname {Vec} (\mathbb {R} ,n)} would be the type of a function which, given a natural number n , returns a tuple of real numbers of size n . The usual function space arises as a special case when the range type does not actually depend on the input. E.g. ∏ n : N R {\textstyle \prod _{n:\mathbb {N} }{\mathbb {R} }} is the type of functions from natural numbers to the real numbers, which is written as N → R {\displaystyle \mathbb {N} \to \mathbb {R} } in typed lambda calculus.

For a more concrete example, taking A {\displaystyle A} to be the type of unsigned integers from 0 to 255 (the ones that fit into 8 bits or 1 byte) and B ( a ) = X a {\displaystyle B(a)=X_{a}} for a : A {\displaystyle a:A} , then ∏ x : A B ( x ) {\textstyle \prod _{x:A}B(x)} devolves into the product of X 0 × X 1 × X 2 × … × X 253 × X 254 × X 255 {\displaystyle X_{0}\times X_{1}\times X_{2}\times \ldots \times X_{253}\times X_{254}\times X_{255}} .

The dual of the dependent product type is the dependent pair type , dependent sum type , sigma-type , or (confusingly) dependent product type . Sigma-types can also be understood as existential quantifiers . Continuing the above example, if, in the universe of types U {\displaystyle {\mathcal {U}}} , there is a type A : U {\displaystyle A:{\mathcal {U}}} and a family of types B : A → U {\displaystyle B:A\to {\mathcal {U}}} , then there is a dependent pair type ∑ x : A B ( x ) {\textstyle \sum _{x:A}B(x)} . (The alternative notations are similar to that of Π types.)

The dependent pair type captures the idea of an ordered pair where the type of the second term is dependent on the value of the first. If ( a , b ) : ∑ x : A B ( x ) , {\textstyle (a,b):\sum _{x:A}B(x),} then a : A {\displaystyle a:A} and b : B ( a ) {\displaystyle b:B(a)} . If B {\displaystyle B} is a constant function, then the dependent pair type becomes (is judgementally equal to) the product type , that is, an ordinary Cartesian product A × B {\displaystyle A\times B} .

For a more concrete example, taking A {\displaystyle A} to again be type of unsigned integers from 0 to 255, and B ( a ) {\displaystyle B(a)} to again be equal to X a {\displaystyle X_{a}} for 256 more arbitrary X a {\displaystyle X_{a}} , then ∑ x : A B ( x ) {\textstyle \sum _{x:A}B(x)} devolves into the sum X 0 + X 1 + X 2 + … + X 253 + X 254 + X 255 {\displaystyle X_{0}+X_{1}+X_{2}+\ldots +X_{253}+X_{254}+X_{255}} .

Let A : U {\displaystyle A:{\mathcal {U}}} be some type, and let B : A → U {\displaystyle B:A\to {\mathcal {U}}} . By the Curry–Howard correspondence, B {\displaystyle B} can be interpreted as a logical predicate on terms of A {\displaystyle A} . For a given a : A {\displaystyle a:A} , whether the type B ( a ) {\displaystyle B(a)} is inhabited indicates whether a {\displaystyle a} satisfies this predicate. The correspondence can be extended to existential quantification and dependent pairs: the proposition ∃ a ∈ A B ( a ) {\displaystyle \exists {a}{\in }A\,B(a)} is true if and only if the type ∑ a : A B ( a ) {\textstyle \sum _{a:A}B(a)} is inhabited.

For example, m : N {\displaystyle m:\mathbb {N} } is less than or equal to n : N {\displaystyle n:\mathbb {N} } if and only if there exists another natural number k : N {\displaystyle k:\mathbb {N} } such that m + k = n {\displaystyle m+k=n} . In logic, this statement is codified by existential quantification:

m ≤ n ⟺ ∃ k ∈ N m + k = n . {\displaystyle m\leq n\iff \exists {k}{\in }\mathbb {N} \,m+k=n.}

This proposition corresponds to the dependent pair type:

∑ k : N m + k = n . {\displaystyle \sum _{k:\mathbb {N} }m+k=n.}

That is, a proof of the statement that m {\displaystyle m} is less than or equal to n {\displaystyle n} is a pair that contains both a non-negative number k {\displaystyle k} , which is the difference between m {\displaystyle m} and n {\displaystyle n} , and a proof of the equality m + k = n {\displaystyle m+k=n} .

Henk Barendregt developed the lambda cube as a means of classifying type systems along three axes.  The eight corners of the resulting cube-shaped diagram each correspond to a type system, with simply typed lambda calculus in the least expressive corner, and calculus of constructions in the most expressive.  The three axes of the cube correspond to three different augmentations of the simply typed lambda calculus: the addition of dependent types, the addition of polymorphism, and the addition of higher kinded type constructors (functions from types to types, for example).  The lambda cube is generalized further by pure type systems .

The system λ Π {\displaystyle \lambda \Pi } of pure first order dependent types, corresponding to the logical framework LF , is obtained by generalising the function space type of the simply typed lambda calculus to the dependent product type.

The system λ Π 2 {\displaystyle \lambda \Pi 2} of second order dependent types is obtained from λ Π {\displaystyle \lambda \Pi } by allowing quantification over type constructors. In this theory the dependent product operator subsumes both the → {\displaystyle \to } operator of simply typed lambda calculus and the ∀ {\displaystyle \forall } binder of System F .

The higher order system λ Π ω {\displaystyle \lambda \Pi \omega } extends λ Π 2 {\displaystyle \lambda \Pi 2} to all four forms of abstraction from the lambda cube : functions from terms to terms, types to types, terms to types and types to terms. The system corresponds to the calculus of constructions whose derivative, the calculus of inductive constructions is the underlying system of the Coq proof assistant .

The Curry–Howard correspondence implies that types can be constructed that express arbitrarily complex mathematical properties. If the user can supply a constructive proof that a type is inhabited (i.e., that a value of that type exists) then a compiler can check the proof and convert it into executable computer code that computes the value by carrying out the construction. The proof checking feature makes dependently typed languages closely related to proof assistants . The code-generation aspect provides a powerful approach to formal program verification and proof-carrying code , since the code is derived directly from a mechanically verified mathematical proof.