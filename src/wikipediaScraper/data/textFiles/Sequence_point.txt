In C and C++ , a sequence point defines any point in a computer program 's execution at which it is guaranteed that all side effects of previous evaluations will have been performed, and no side effects from subsequent evaluations have yet been performed. They are a core concept for determining the validity of and, if valid, the possible results of expressions. Adding more sequence points is sometimes necessary to make an expression defined and to ensure a single valid order of evaluation.

With C11 and C++11 , usage of the term sequence point has been replaced by sequencing. There are three possibilities:

The execution of unsequenced evaluations can overlap, leading to potentially catastrophic undefined behavior if they share state . This situation can arise in parallel computations , causing race conditions , but undefined behavior can also result in single-threaded situations. For example, a[i] = i++; (where a is an array and i is an integer) has undefined behavior.

Consider two functions f() and g() . In C and C++, the + operator is not associated with a sequence point, and therefore in the expression f()+g() it is possible that either f() or g() will be executed first. The comma operator introduces a sequence point, and therefore in the code f(),g() the order of evaluation is defined: first f() is called, and then g() is called.

Sequence points also come into play when the same variable is modified more than once within a single expression. An often-cited example is the C expression i=i++ , which apparently both assigns i its previous value and increments i . The final value of i is ambiguous, because, depending on the order of expression evaluation, the increment may occur before, after, or interleaved with the assignment. The definition of a particular language might specify one of the possible behaviors or simply say the behavior is undefined . In C and C++, evaluating such an expression yields undefined behavior. Other languages, such as C# , define the precedence of the assignment and increment operator in such a way that the result of the expression i=i++ is guaranteed.

In C and C++, sequence points occur in the following places. (In C++, overloaded operators act like functions, and thus operators that have been overloaded introduce sequence points in the same way as function calls.)

Partially because of the introduction of language support for threads, C11 and C++11 introduced new terminology for evaluation order. An operation may be "sequenced before" another, or the two can be "indeterminately" sequenced (one must complete before the other) or "unsequenced" (the operations in each expression may be interleaved).

C++17 restricted several aspects of evaluation order. The new expression will always perform the memory allocation before evaluating the constructor arguments. The operators << , >> , . , .* , ->* , and the subscript and function call operator are guaranteed to be evaluated left to right (whether they are overloaded or not). For example, the code

is newly guaranteed to call a , b and c in that order. The right-hand side of any assignment-like operator is evaluated before the left-hand side, so that b() *= a(); is guaranteed to evaluate a first. Finally, although the order in which function parameters are evaluated remains implementation-defined, the compiler is no longer allowed to interleave sub-expressions across multiple parameters.